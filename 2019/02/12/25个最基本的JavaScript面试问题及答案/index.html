<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">

    

    
    <title>25个最基本的JavaScript面试问题及答案 | 陈义的个人博客</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="JavaScript">
    
    <meta name="description" content="1.使用typeof bar === &amp;quot;object&amp;quot;来确定bar是否是对象的潜在陷阱是什么？如何避免这个陷阱？尽管typeof bar === &amp;quot;object&amp;quot;是检查bar是否对象的可靠方法，令人惊讶的是在JavaScript中null也被认为是对象！ 因此，令大多数开发人员惊讶的是，下面的代码将输出true(而不是false) 到控制台：12var b">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="25个最基本的JavaScript面试问题及答案">
<meta property="og:url" content="http://yoursite.com/2019/02/12/25个最基本的JavaScript面试问题及答案/index.html">
<meta property="og:site_name" content="陈义的个人博客">
<meta property="og:description" content="1.使用typeof bar === &amp;quot;object&amp;quot;来确定bar是否是对象的潜在陷阱是什么？如何避免这个陷阱？尽管typeof bar === &amp;quot;object&amp;quot;是检查bar是否对象的可靠方法，令人惊讶的是在JavaScript中null也被认为是对象！ 因此，令大多数开发人员惊讶的是，下面的代码将输出true(而不是false) 到控制台：12var b">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/02/12/25个最基本的JavaScript面试问题及答案/68423.JPEG">
<meta property="og:updated_time" content="2019-02-12T12:00:34.649Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="25个最基本的JavaScript面试问题及答案">
<meta name="twitter:description" content="1.使用typeof bar === &amp;quot;object&amp;quot;来确定bar是否是对象的潜在陷阱是什么？如何避免这个陷阱？尽管typeof bar === &amp;quot;object&amp;quot;是检查bar是否对象的可靠方法，令人惊讶的是在JavaScript中null也被认为是对象！ 因此，令大多数开发人员惊讶的是，下面的代码将输出true(而不是false) 到控制台：12var b">
<meta name="twitter:image" content="http://yoursite.com/2019/02/12/25个最基本的JavaScript面试问题及答案/68423.JPEG">
    

    
        <link rel="alternate" href="/" title="陈义的个人博客" type="application/atom+xml">
    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/3.3.1/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    


</head>
</html>
<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">学而不思则罔，思而不学则殆</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item">
                                    <a class="main-nav-list-link" href="/">主页</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/遥感/">遥感</a></li></ul>
                                    
                                <li class="main-nav-list-item">
                                    <a class="main-nav-list-link" href="/about/index.html">关于</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    未分类
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-25个最基本的JavaScript面试问题及答案" class="article article-single article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        25个最基本的JavaScript面试问题及答案
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2019/02/12/25个最基本的JavaScript面试问题及答案/" class="article-date">
            <time datetime="2019-02-12T10:51:29.000Z" itemprop="datePublished">2019-02-12</time>
        </a>
    </div>

		

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <p><img src="/2019/02/12/25个最基本的JavaScript面试问题及答案/68423.JPEG" alt=""></p>
<h2 id="1-使用typeof-bar-quot-object-quot-来确定bar是否是对象的潜在陷阱是什么？如何避免这个陷阱？"><a href="#1-使用typeof-bar-quot-object-quot-来确定bar是否是对象的潜在陷阱是什么？如何避免这个陷阱？" class="headerlink" title="1.使用typeof bar === &quot;object&quot;来确定bar是否是对象的潜在陷阱是什么？如何避免这个陷阱？"></a>1.使用<code>typeof bar === &quot;object&quot;</code>来确定<code>bar</code>是否是对象的潜在陷阱是什么？如何避免这个陷阱？</h2><p>尽管<code>typeof bar === &quot;object&quot;</code>是检查<code>bar</code>是否对象的可靠方法，令人惊讶的是在JavaScript中<code>null</code>也被认为是对象！</p>
<p>因此，令大多数开发人员惊讶的是，下面的代码将输出<code>true</code>(而不是false) 到控制台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var bar = null;</span><br><span class="line">console.log(typeof bar === &quot;object&quot;);  // logs true!</span><br></pre></td></tr></table></figure></p>
<p>只要清楚这一点，同时检查<code>bar</code>是否为<code>null</code>，就可以很容易地避免问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log((bar !== null) &amp;&amp; (typeof bar === &quot;object&quot;));  // logs false</span><br></pre></td></tr></table></figure></p>
<p>要答全问题，还有其他两件事情值得注意：</p>
<p>首先，上述解决方案将返回<code>false</code>，当<code>bar</code>是一个函数的时候。在大多数情况下，这是期望行为，但当你也想对函数返回<code>true</code>的话，你可以修改上面的解决方案为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log((bar !== null) &amp;&amp; ((typeof bar === &quot;object&quot;) || (typeof bar === &quot;function&quot;)));</span><br></pre></td></tr></table></figure></p>
<p>第二，上述解决方案将返回<code>true</code>，当<code>bar</code>是一个数组（例如，当<code>var bar = [];</code>）的时候。在大多数情况下，这是期望行为，因为数组是真正的对象，但当你也想对数组返回 false 时，你可以修改上面的解决方案为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log((bar !== null) &amp;&amp; (typeof bar === &quot;object&quot;) &amp;&amp; (toString.call(bar) !== &quot;[object Array]&quot;));</span><br></pre></td></tr></table></figure></p>
<p>或者，如果你使用jQuery的话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log((bar !== null) &amp;&amp; (typeof bar === &quot;object&quot;) &amp;&amp; (! $.isArray(bar)));</span><br></pre></td></tr></table></figure></p>
<h2 id="2-下面的代码将输出什么到控制台，为什么？"><a href="#2-下面的代码将输出什么到控制台，为什么？" class="headerlink" title="2.下面的代码将输出什么到控制台，为什么？"></a>2.下面的代码将输出什么到控制台，为什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">  var a = b = 3;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(&quot;a defined? &quot; + (typeof a !== &apos;undefined&apos;));</span><br><span class="line">console.log(&quot;b defined? &quot; + (typeof b !== &apos;undefined&apos;));</span><br></pre></td></tr></table></figure>
<p>由于<code>a</code>和<code>b</code>都定义在函数的封闭范围内，并且都始于<code>var</code>关键字，大多数JavaScript开发人员期望<code>typeof a</code>和<code>typeof b</code>在上面的例子中都是undefined。</p>
<p>然而，事实并非如此。这里的问题是，大多数开发人员将语句<code>var a = b = 3;</code> 错误地理解为是以下声明的简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var b = 3;</span><br><span class="line">var a = b;</span><br></pre></td></tr></table></figure></p>
<p>但事实上，<code>var a = b = 3;</code>实际是以下声明的简写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = 3;</span><br><span class="line">var a = b;</span><br></pre></td></tr></table></figure></p>
<p>因此（如果你不使用严格模式的话），该代码段的输出是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a defined? false</span><br><span class="line">b defined? true</span><br></pre></td></tr></table></figure></p>
<p>但是，<code>b</code>如何才能被定义在封闭函数的范围之外呢？是的，既然语句<code>var a = b = 3;</code> 是语句<code>b = 3;</code>和<code>var a = b;</code>的简写，<code>b</code>最终成为了一个全局变量（因为它没有前缀<code>var</code>关键字），因此仍然在范围内甚至封闭函数之外。</p>
<p>需要注意的是，在严格模式下（即使用<code>use strict</code>），语句var a = b = 3; 将生成<code>ReferenceError: b is not defined</code>的运行时错误，从而避免任何否则可能会导致的headfakes /bug。 （还是你为什么应该理所当然地在代码中使用 use strict 的最好例子！）</p>
<h2 id="3-下面的代码将输出什么到控制台，为什么？"><a href="#3-下面的代码将输出什么到控制台，为什么？" class="headerlink" title="3.下面的代码将输出什么到控制台，为什么？"></a>3.下面的代码将输出什么到控制台，为什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var myObject = &#123;</span><br><span class="line">    foo: &quot;bar&quot;,</span><br><span class="line">    func: function() &#123;</span><br><span class="line">        var self = this;</span><br><span class="line">        console.log(&quot;outer func:  this.foo = &quot; + this.foo);</span><br><span class="line">        console.log(&quot;outer func:  self.foo = &quot; + self.foo);</span><br><span class="line">        (function() &#123;</span><br><span class="line">            console.log(&quot;inner func:  this.foo = &quot; + this.foo);</span><br><span class="line">            console.log(&quot;inner func:  self.foo = &quot; + self.foo);</span><br><span class="line">        &#125;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">myObject.func();</span><br></pre></td></tr></table></figure>
<p>上面的代码将输出以下内容到控制台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">outer func:  this.foo = bar</span><br><span class="line">outer func:  self.foo = bar</span><br><span class="line">inner func:  this.foo = undefined</span><br><span class="line">inner func:  self.foo = bar</span><br></pre></td></tr></table></figure></p>
<p>在外部函数中，<code>this</code>和<code>self</code>两者都指向了<code>myObject</code>，因此两者都可以正确地引用和访问<code>foo</code>。</p>
<p>在内部函数中，<code>this</code>不再指向<code>myObject</code>。其结果是，<code>this.foo</code>没有在内部函数中被定义，相反，指向到本地的变量<code>self</code>保持在范围内，并且可以访问。 （在ECMA 5之前，在内部函数中的<code>this</code> 将指向全局的<code>window</code>对象；反之，因为作为ECMA 5，内部函数中的功能<code>this</code>是未定义的。）</p>
<h2 id="4-封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？"><a href="#4-封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？" class="headerlink" title="4.封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？"></a>4.封装JavaScript源文件的全部内容到一个函数块有什么意义及理由？</h2><p>这是一个越来越普遍的做法，被许多流行的JavaScript库（jQuery，Node.js等）采用。这种技术创建了一个围绕文件全部内容的闭包，也许是最重要的是，创建了一个私有的命名空间，从而有助于避免不同JavaScript模块和库之间潜在的名称冲突。</p>
<p>这种技术的另一个特点是，允许一个易于引用的（假设更短的）别名用于全局变量。这通常用于，例如，jQuery插件中。jQuery允许你使用<code>jQuery.noConflict()</code>，来禁用<code>$</code>引用到jQuery命名空间。在完成这项工作之后，你的代码仍然可以使用<code>$</code>利用这种闭包技术，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function($) &#123; /* jQuery plugin code referencing $ */ &#125; )(jQuery);</span><br></pre></td></tr></table></figure></p>
<h2 id="5-在JavaScript源文件的开头包含use-strict有什么意义和好处？"><a href="#5-在JavaScript源文件的开头包含use-strict有什么意义和好处？" class="headerlink" title="5.在JavaScript源文件的开头包含use strict有什么意义和好处？"></a>5.在JavaScript源文件的开头包含<code>use strict</code>有什么意义和好处？</h2><p>对于这个问题，既简要又最重要的答案是，<code>use strict</code>是一种在JavaScript代码运行时自动实行更严格解析和错误处理的方法。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常。通常而言，这是一个很好的做法。<br>严格模式的一些主要优点包括：</p>
<ul>
<li>使调试更加容易。那些被忽略或默默失败了的代码错误，会产生错误或抛出异常，因此尽早提醒你代码中的问题，你才能更快地指引到它们的源代码。</li>
<li>防止意外的全局变量。如果没有严格模式，将值分配给一个未声明的变量会自动创建该名称的全局变量。这是JavaScript中最常见的错误之一。在严格模式下，这样做的话会抛出错误。</li>
<li>消除 this 强制。如果没有严格模式，引用null或未定义的值到 this 值会自动强制到全局变量。这可能会导致许多令人头痛的问题和让人恨不得拔自己头发的bug。在严格模式下，引用 null或未定义的 this 值会抛出错误。</li>
<li>不允许重复的属性名称或参数值。当检测到对象（例如，var object = {foo: “bar”, foo: “baz”};）中重复命名的属性，或检测到函数中（例如，function foo(val1, val2, val1){}）重复命名的参数时，严格模式会抛出错误，因此捕捉几乎可以肯定是代码中的bug可以避免浪费大量的跟踪时间。</li>
<li>使eval() 更安全。在严格模式和非严格模式下，eval() 的行为方式有所不同。最显而易见的是，在严格模式下，变量和声明在 eval() 语句内部的函数不会在包含范围内创建（它们会在非严格模式下的包含范围中被创建，这也是一个常见的问题源）。</li>
<li>在 delete使用无效时抛出错误。delete操作符（用于从对象中删除属性）不能用在对象不可配置的属性上。当试图删除一个不可配置的属性时，非严格代码将默默地失败，而严格模式将在这样的情况下抛出异常。</li>
</ul>
<h2 id="6-考虑以下两个函数。它们会返回相同的东西吗？-为什么相同或为什么不相同？"><a href="#6-考虑以下两个函数。它们会返回相同的东西吗？-为什么相同或为什么不相同？" class="headerlink" title="6.考虑以下两个函数。它们会返回相同的东西吗？ 为什么相同或为什么不相同？"></a>6.考虑以下两个函数。它们会返回相同的东西吗？ 为什么相同或为什么不相同？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function foo1()</span><br><span class="line">&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">      bar: &quot;hello&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo2()</span><br><span class="line">&#123;</span><br><span class="line">  return</span><br><span class="line">  &#123;</span><br><span class="line">      bar: &quot;hello&quot;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出人意料的是，这两个函数返回的内容并不相同。更确切地说是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;foo1 returns:&quot;);</span><br><span class="line">console.log(foo1());</span><br><span class="line">console.log(&quot;foo2 returns:&quot;);</span><br><span class="line">console.log(foo2());</span><br></pre></td></tr></table></figure></p>
<p>将产生：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo1 returns:</span><br><span class="line">Object &#123;bar: &quot;hello&quot;&#125;</span><br><span class="line">foo2 returns:</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure></p>
<p>这不仅是令人惊讶，而且特别让人困惑的是，<code>foo2()</code>返回undefined却没有任何错误抛出。</p>
<p>原因与这样一个事实有关，即分号在JavaScript中是一个可选项（尽管省略它们通常是非常糟糕的形式）。其结果就是，当碰到<code>foo2()</code>中包含<code>return</code>语句的代码行（代码行上没有其他任何代码），分号会立即自动插入到返回语句之后。</p>
<p>也不会抛出错误，因为代码的其余部分是完全有效的，即使它没有得到调用或做任何事情（相当于它就是是一个未使用的代码块，定义了等同于字符串 <code>&quot;hello&quot;</code>的属性 <code>bar</code>）。</p>
<p>这种行为也支持放置左括号于JavaScript代码行的末尾，而不是新代码行开头的约定。正如这里所示，这不仅仅只是JavaScript中的一个风格偏好。</p>
<h2 id="7-NaN-是什么？它的类型是什么？你如何可靠地测试一个值是否等于NaN？"><a href="#7-NaN-是什么？它的类型是什么？你如何可靠地测试一个值是否等于NaN？" class="headerlink" title="7. NaN 是什么？它的类型是什么？你如何可靠地测试一个值是否等于NaN？"></a>7. <code>NaN</code> 是什么？它的类型是什么？你如何可靠地测试一个值是否等于<code>NaN</code>？</h2><p><code>NaN</code>属性代表一个“不是数字”的值。这个特殊的值是因为运算不能执行而导致的，不能执行的原因要么是因为其中的运算对象之一非数字（例如，<code>&quot;abc&quot; / 4</code>），要么是因为运算的结果非数字（例如，除数为零）。</p>
<p>虽然这看上去很简单，但<code>NaN</code>有一些令人惊讶的特点，如果你不知道它们的话，可能会导致令人头痛的bug。</p>
<p>首先，虽然<code>NaN</code>意味着“不是数字”，但是它的类型，不管你信不信，是<code>Number</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof NaN === &quot;number&quot;);  // logs &quot;true&quot;</span><br></pre></td></tr></table></figure></p>
<p>此外，<code>NaN</code>和任何东西比较——甚至是它自己本身！——结果是false：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(NaN === NaN);  // logs &quot;false&quot;</span><br></pre></td></tr></table></figure></p>
<p>一种半可靠的方法来测试一个数字是否等于 NaN，是使用内置函数<code>isNaN()</code>，但即使使用<code>isNaN()</code> 依然并非是一个完美的解决方案。</p>
<p>一个更好的解决办法是使用<code>value !== value</code>，如果值等于NaN，只会产生true。另外，ES6提供了一个新的<code>Number.isNaN()</code>函数，这是一个不同的函数，并且比老的全局<code>isNaN()</code>函数更可靠。</p>
<h2 id="8-下列代码将输出什么？并解释原因。"><a href="#8-下列代码将输出什么？并解释原因。" class="headerlink" title="8.下列代码将输出什么？并解释原因。"></a>8.下列代码将输出什么？并解释原因。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(0.1 + 0.2);</span><br><span class="line">console.log(0.1 + 0.2 == 0.3);</span><br></pre></td></tr></table></figure>
<p>一个稍微有点编程基础的回答是：“你不能确定。可能会输出“0.3”和“true”，也可能不会。JavaScript中的数字和浮点精度的处理相同，因此，可能不会总是产生预期的结果。“</p>
<p>以上所提供的例子就是一个演示了这个问题的典型例子。但出人意料的是，它会输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0.30000000000000004</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p>
<h2 id="9-讨论写函数isInteger-x-的可能方法，用于确定x是否是整数。"><a href="#9-讨论写函数isInteger-x-的可能方法，用于确定x是否是整数。" class="headerlink" title="9.讨论写函数isInteger(x)的可能方法，用于确定x是否是整数。"></a>9.讨论写函数<code>isInteger(x)</code>的可能方法，用于确定x是否是整数。</h2><p>这可能听起来是小菜一碟，但事实上，这很琐碎，因为ECMAScript 6引入了一个新的正以此为目的<code>Number.isInteger()</code>函数。然而，之前的ECMAScript 6，会更复杂一点，因为没有提供类似的<code>Number.isInteger()</code>方法。</p>
<p>问题是，在ECMAScript规格说明中，整数只概念上存在：即，数字值总是存储为浮点值。</p>
<p>考虑到这一点，最简单又最干净的ECMAScript6之前的解决方法（同时也非常稳健地返回<code>false</code>，即使一个非数字的值，如字符串或<code>null</code>，被传递给函数）如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function isInteger(x) &#123; return (x^0) === x; &#125;</span><br></pre></td></tr></table></figure></p>
<p>下面的解决方法也是可行的，虽然不如上面那个方法优雅：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function isInteger(x) &#123; return Math.round(x) === x; &#125;</span><br></pre></td></tr></table></figure></p>
<p>请注意<code>Math.ceil()</code>和<code>Math.floor()</code>在上面的实现中等同于<code>Math.round()</code>。</p>
<p>或：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function isInteger(x) &#123; return (typeof x === &apos;number&apos;) &amp;&amp; (x % 1 === 0);</span><br></pre></td></tr></table></figure></p>
<p>相当普遍的一个不正确的解决方案是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function isInteger(x) &#123; return parseInt(x, 10) === x; &#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然这个以<code>parseInt</code>函数为基础的方法在<code>x</code>取许多值时都能工作良好，但一旦 x 取值相当大的时候，就会无法正常工作。问题在于<code>parseInt()</code>在解析数字之前强制其第一个参数到字符串。因此，一旦数目变得足够大，它的字符串就会表达为指数形式（例如， 1e+21）。因此，parseInt() 函数就会去解析 1e+21，但当到达 e字符串的时候，就会停止解析，因此只会返回值 1。注意：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; String(1000000000000000000000)</span><br><span class="line">&apos;1e+21&apos;</span><br><span class="line"></span><br><span class="line">&gt; parseInt(1000000000000000000000, 10)</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">&gt; parseInt(1000000000000000000000, 10) === 1000000000000000000000</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p>
<h2 id="10-下列代码行1-4如何排序，使之能够在执行代码时输出到控制台？-为什么？"><a href="#10-下列代码行1-4如何排序，使之能够在执行代码时输出到控制台？-为什么？" class="headerlink" title="10.下列代码行1-4如何排序，使之能够在执行代码时输出到控制台？ 为什么？"></a>10.下列代码行1-4如何排序，使之能够在执行代码时输出到控制台？ 为什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">    console.log(1); </span><br><span class="line">    setTimeout(function()&#123;console.log(2)&#125;, 1000); </span><br><span class="line">    setTimeout(function()&#123;console.log(3)&#125;, 0); </span><br><span class="line">    console.log(4);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>序号如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>让我们先来解释比较明显而易见的那部分：</p>
<ul>
<li>1和4之所以放在前面，是因为它们是通过简单调用console.log()而没有任何延迟输出的</li>
<li>2之所以放在3的后面，是因为2是延迟了1000毫秒（即，1秒）之后输出的，而 3 是延迟了0毫秒之后输出的。</li>
</ul>
<p>好的。但是，既然3是0毫秒延迟之后输出的，那么是否意味着它是立即输出的呢？如果是的话，那么它是不是应该在4之前输出，既然4是在第二行输出的？</p>
<p>要回答这个问题，你需要正确理解JavaScript的事件和时间设置。</p>
<p>浏览器有一个事件循环，会检查事件队列和处理未完成的事件。例如，如果时间发生在后台（例如，脚本的<code>onload</code>事件）时，浏览器正忙（例如，处理一个<code>onclick</code>），那么事件会添加到队列中。当onclick处理程序完成后，检查队列，然后处理该事件（例如，执行 onload 脚本）。</p>
<p>同样的， <code>setTimeout()</code>也会把其引用的函数的执行放到事件队列中，如果浏览器正忙的话。</p>
<p>当<code>setTimeout()</code>的第二个参数为0的时候，它的意思是“尽快”执行指定的函数。具体而言，函数的执行会放置在事件队列的下一个计时器开始。但是请注意，这不是立即执行：函数不会被执行除非下一个计时器开始。这就是为什么在上述的例子中，调用 console.log(4) 发生在调用 console.log(3) 之前（因为调用 console.log(3) 是通过setTimeout被调用的，因此会稍微延迟）。</p>
<h2 id="11-写一个简单的函数（少于80个字符），要求返回一个布尔值指明字符串是否为回文结构。"><a href="#11-写一个简单的函数（少于80个字符），要求返回一个布尔值指明字符串是否为回文结构。" class="headerlink" title="11.写一个简单的函数（少于80个字符），要求返回一个布尔值指明字符串是否为回文结构。"></a>11.写一个简单的函数（少于80个字符），要求返回一个布尔值指明字符串是否为回文结构。</h2><p>下面这个函数在<code>str</code>是回文结构的时候返回true，否则，返回false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function isPalindrome(str) &#123;</span><br><span class="line">    str = str.replace(/\W/g, &apos;&apos;).toLowerCase();</span><br><span class="line">    return (str == str.split(&apos;&apos;).reverse().join(&apos;&apos;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(isPalindrome(&quot;level&quot;));                   // logs &apos;true&apos;</span><br><span class="line">console.log(isPalindrome(&quot;levels&quot;));                  // logs &apos;false&apos;</span><br><span class="line">console.log(isPalindrome(&quot;A car, a man, a maraca&quot;));  // logs &apos;true&apos;</span><br></pre></td></tr></table></figure></p>
<h2 id="12-写一个-sum方法，在使用下面任一语法调用时，都可以正常工作。"><a href="#12-写一个-sum方法，在使用下面任一语法调用时，都可以正常工作。" class="headerlink" title="12.写一个 sum方法，在使用下面任一语法调用时，都可以正常工作。"></a>12.写一个 sum方法，在使用下面任一语法调用时，都可以正常工作。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(sum(2,3));   // Outputs 5</span><br><span class="line">console.log(sum(2)(3));  // Outputs 5</span><br></pre></td></tr></table></figure>
<p>（至少）有两种方法可以做到：</p>
<p>方法1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(x) &#123;</span><br><span class="line">  if (arguments.length == 2) &#123;</span><br><span class="line">    return arguments[0] + arguments[1];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return function(y) &#123; return x + y; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在JavaScript中，函数可以提供到<code>arguments</code>对象的访问，arguments 对象提供传递到函数的实际参数的访问。这使我们能够使用<code>length</code>属性来确定在运行时传递给函数的参数数量。</p>
<p>如果传递两个参数，那么只需加在一起，并返回。</p>
<p>否则，我们假设它被以<code>sum(2)(3)</code>这样的形式调用，所以我们返回一个匿名函数，这个匿名函数合并了传递到<code>sum()</code>的参数和传递给匿名函数的参数。</p>
<p>方法2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function sum(x, y) &#123;</span><br><span class="line">  if (y !== undefined) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return function(y) &#123; return x + y; &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当调用一个函数的时候，JavaScript不要求参数的数目匹配函数定义中的参数数量。如果传递的参数数量大于函数定义中参数数量，那么多余参数将简单地被忽略。另一方面，如果传递的参数数量小于函数定义中的参数数量，那么缺少的参数在函数中被引用时将会给一个 undefined值。所以，在上面的例子中，简单地检查第2个参数是否未定义，就可以相应地确定函数被调用以及进行的方式。</p>
<h2 id="13-请看下面的代码片段："><a href="#13-请看下面的代码片段：" class="headerlink" title="13.请看下面的代码片段："></a>13.请看下面的代码片段：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  var btn = document.createElement(&apos;button&apos;);</span><br><span class="line">  btn.appendChild(document.createTextNode(&apos;Button &apos; + i));</span><br><span class="line">  btn.addEventListener(&apos;click&apos;, function()&#123; console.log(i); &#125;);</span><br><span class="line">  document.body.appendChild(btn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（a）当用户点击“Button 4”的时候会输出什么到控制台，为什么？（b）提供一个或多个备用的可按预期工作的实现方案。</p>
<p>（b）无论用户点击什么按钮，数字5将总会输出到控制台。这是因为，当<code>onclick</code>方法被调用（对于任何按钮）的时候，<code>for</code>循环已经结束，变量<code>i</code>已经获得了5的值。（面试者如果能够谈一谈有关如何执行上下文，可变对象，激活对象和内部“范围”属性贡有助于闭包行为，则可以加分）。</p>
<p>（c）要让代码工作的关键是，通过传递到一个新创建的函数对象，在每次传递通过<code>for</code>循环时，捕捉到<code>i</code>值。下面是三种可能实现的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  var btn = document.createElement(&apos;button&apos;);</span><br><span class="line">  btn.appendChild(document.createTextNode(&apos;Button &apos; + i));</span><br><span class="line">  btn.addEventListener(&apos;click&apos;, (function(i) &#123;</span><br><span class="line">    return function() &#123; console.log(i); &#125;;</span><br><span class="line">  &#125;)(i));</span><br><span class="line">  document.body.appendChild(btn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者，你可以封装全部调用到在新匿名函数中的<code>btn.addEventListener</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  var btn = document.createElement(&apos;button&apos;);</span><br><span class="line">  btn.appendChild(document.createTextNode(&apos;Button &apos; + i));</span><br><span class="line">  (function (i) &#123;</span><br><span class="line">    btn.addEventListener(&apos;click&apos;, function() &#123; console.log(i); &#125;);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">  document.body.appendChild(btn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以调用数组对象的本地<code>forEach</code>方法来替代<code>for</code>循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;].forEach(function (value, i) &#123;</span><br><span class="line">  var btn = document.createElement(&apos;button&apos;);</span><br><span class="line">  btn.appendChild(document.createTextNode(&apos;Button &apos; + i));</span><br><span class="line">  btn.addEventListener(&apos;click&apos;, function() &#123; console.log(i); &#125;);</span><br><span class="line">  document.body.appendChild(btn);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="14-下面的代码将输出什么到控制台，为什么？"><a href="#14-下面的代码将输出什么到控制台，为什么？" class="headerlink" title="14.下面的代码将输出什么到控制台，为什么？"></a>14.下面的代码将输出什么到控制台，为什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = &quot;john&quot;.split(&apos;&apos;);</span><br><span class="line">var arr2 = arr1.reverse();</span><br><span class="line">var arr3 = &quot;jones&quot;.split(&apos;&apos;);</span><br><span class="line">arr2.push(arr3);</span><br><span class="line">console.log(&quot;array 1: length=&quot; + arr1.length + &quot; last=&quot; + arr1.slice(-1));</span><br><span class="line">console.log(&quot;array 2: length=&quot; + arr2.length + &quot; last=&quot; + arr2.slice(-1));</span><br></pre></td></tr></table></figure>
<p>输出结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;array 1: length=5 last=j,o,n,e,s&quot;</span><br><span class="line">&quot;array 2: length=5 last=j,o,n,e,s&quot;</span><br></pre></td></tr></table></figure></p>
<p><code>arr1</code>和<code>arr2</code>在上述代码执行之后，两者相同了，原因是：</p>
<ul>
<li>调用数组对象的<code>reverse()</code>方法并不只返回反顺序的阵列，它也反转了数组本身的顺序（即，在这种情况下，指的是<code>arr1</code>）。</li>
<li><code>reverse()</code>方法返回一个到数组本身的引用（在这种情况下即，<code>arr1</code>）。其结果为，<code>arr2</code>仅仅是一个到 arr1的引用（而不是副本）。因此，当对<code>arr2</code>做了任何事情（即当我们调用 arr2.push(arr3);）时，arr1 也会受到影响，因为 arr1 和 arr2 引用的是同一个对象。<br>这里有几个侧面点有时候会让你在回答这个问题时，阴沟里翻船：</li>
</ul>
<p>传递数组到另一个数组的<code>push()</code>方法会让整个数组作为单个元素映射到数组的末端。其结果是，语句<code>arr2.push(arr3);</code> 在其整体中添加<code>arr3</code>作为一个单一的元素到<code>arr2</code>的末端（也就是说，它并没有连接两个数组，连接数组是 concat() 方法的目的）。</p>
<p>和Python一样，JavaScript标榜数组方法调用中的负数下标，例如<code>slice()</code>可作为引用数组末尾元素的方法：例如，-1下标表示数组中的最后一个元素，等等。</p>
<h2 id="15-下面的代码将输出什么到控制台，为什么？"><a href="#15-下面的代码将输出什么到控制台，为什么？" class="headerlink" title="15.下面的代码将输出什么到控制台，为什么？"></a>15.下面的代码将输出什么到控制台，为什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(1 +  &quot;2&quot; + &quot;2&quot;);</span><br><span class="line">console.log(1 +  +&quot;2&quot; + &quot;2&quot;);</span><br><span class="line">console.log(1 +  -&quot;1&quot; + &quot;2&quot;);</span><br><span class="line">console.log(+&quot;1&quot; +  &quot;1&quot; + &quot;2&quot;);</span><br><span class="line">console.log( &quot;A&quot; - &quot;B&quot; + &quot;2&quot;);</span><br><span class="line">console.log( &quot;A&quot; - &quot;B&quot; + 2);</span><br></pre></td></tr></table></figure>
<p>上面的代码将输出以下内容到控制台：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;122&quot;</span><br><span class="line">&quot;32&quot;</span><br><span class="line">&quot;02&quot;</span><br><span class="line">&quot;112&quot;</span><br><span class="line">&quot;NaN2&quot;</span><br><span class="line">NaN</span><br></pre></td></tr></table></figure></p>
<p>原因是…</p>
<p>这里的根本问题是，JavaScript（ECMAScript）是一种弱类型语言，它可对值进行自动类型转换，以适应正在执行的操作。让我们通过上面的例子来说明这是如何做到的。</p>
<p>例1：<code>1 + &quot;2&quot; + &quot;2&quot;</code>输出：”122” 说明：<code>1 + &quot;2&quot;</code>是执行的第一个操作。由于其中一个运算对象（”2”）是字符串，JavaScript会假设它需要执行字符串连接，因此，会将 1 的类型转换为 “1”， 1 + “2”结果就是 “12”。然后， “12” + “2” 就是 “122”。</p>
<p>例2：<code>1 + +&quot;2&quot; + &quot;2&quot;</code> 输出： “32” 说明：根据运算的顺序，要执行的第一个运算是 +”2”（第一个 “2” 前面的额外 + 被视为一元运算符）。因此，JavaScript将 “2” 的类型转换为数字，然后应用一元 + 号（即，将其视为一个正数）。其结果是，接下来的运算就是 1 + 2 ，这当然是 3。然后我们需要在一个数字和一个字符串之间进行运算（即， 3 和 “2”），同样的，JavaScript会将数值类型转换为字符串，并执行字符串的连接，产生 “32”。</p>
<p>例3： <code>1 + -&quot;1&quot; + &quot;2&quot;</code>输出： “02”  说明：这里的解释和前一个例子相同，除了此处的一元运算符是 - 而不是 +。先是 “1” 变为 1，然后当应用 - 时又变为了 -1 ，然后将其与 1相加，结果为 0，再将其转换为字符串，连接最后的 “2” 运算对象，得到 “02”。</p>
<p>例4： <code>+&quot;1&quot; + &quot;1&quot; + &quot;2&quot;</code> 输出： “112” 说明：虽然第一个运算对象 “1”因为前缀的一元 + 运算符类型转换为数值，但又立即转换回字符串，当连接到第二个运算对象 “1” 的时候，然后又和最后的运算对象”2” 连接，产生了字符串 “112”。</p>
<p>例5： <code>&quot;A&quot; - &quot;B&quot; + &quot;2&quot;</code> 输出： “NaN2” 说明：由于运算符 -  不能被应用于字符串，并且 “A” 和 “B” 都不能转换成数值，因此，”A” - “B”的结果是 NaN，然后再和字符串 “2” 连接，得到 “NaN2” 。</p>
<p>例6： <code>&quot;A&quot; - &quot;B&quot; + 2</code> 输出： NaN 说明：参见前一个例子， “A” - “B” 结果为 NaN。但是，应用任何运算符到NaN与其他任何的数字运算对象，结果仍然是 NaN。</p>
<h2 id="16-下面的递归代码在数组列表偏大的情况下会导致堆栈溢出。在保留递归模式的基础上，你怎么解决这个问题？"><a href="#16-下面的递归代码在数组列表偏大的情况下会导致堆栈溢出。在保留递归模式的基础上，你怎么解决这个问题？" class="headerlink" title="16.下面的递归代码在数组列表偏大的情况下会导致堆栈溢出。在保留递归模式的基础上，你怎么解决这个问题？"></a>16.下面的递归代码在数组列表偏大的情况下会导致堆栈溢出。在保留递归模式的基础上，你怎么解决这个问题？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var list = readHugeList();</span><br><span class="line"></span><br><span class="line">var nextListItem = function() &#123;</span><br><span class="line">    var item = list.pop();</span><br><span class="line"></span><br><span class="line">    if (item) &#123;</span><br><span class="line">        // process the list item...</span><br><span class="line">        nextListItem();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>潜在的堆栈溢出可以通过修改nextListItem 函数避免：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var list = readHugeList();</span><br><span class="line"></span><br><span class="line">var nextListItem = function() &#123;</span><br><span class="line">    var item = list.pop();</span><br><span class="line"></span><br><span class="line">    if (item) &#123;</span><br><span class="line">        // process the list item...</span><br><span class="line">        setTimeout( nextListItem, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>堆栈溢出之所以会被消除，是因为事件循环操纵了递归，而不是调用堆栈。当<code>nextListItem</code>运行时，如果<code>item</code>不为空，timeout函数（<code>nextListItem</code>）就会被推到事件队列，该函数退出，因此就清空调用堆栈。当事件队列运行其timeout事件，且进行到下一个 item 时，定时器被设置为再次调用 nextListItem。因此，该方法从头到尾都没有直接的递归调用，所以无论迭代次数的多少，调用堆栈保持清空的状态。</p>
<h2 id="17-JavaScript中的“闭包”是什么？请举一个例子。"><a href="#17-JavaScript中的“闭包”是什么？请举一个例子。" class="headerlink" title="17.JavaScript中的“闭包”是什么？请举一个例子。"></a>17.JavaScript中的“闭包”是什么？请举一个例子。</h2><p>闭包是一个可以访问外部（封闭）函数作用域链中的变量的内部函数。闭包可以访问三种范围中的变量：这三个范围具体为：（1）自己范围内的变量，（2）封闭函数范围内的变量，以及（3）全局变量。</p>
<p>下面是一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var globalVar = &quot;xyz&quot;;</span><br><span class="line"></span><br><span class="line">(function outerFunc(outerArg) &#123;</span><br><span class="line">  var outerVar = &apos;a&apos;;</span><br><span class="line"></span><br><span class="line">  (function innerFunc(innerArg) &#123;</span><br><span class="line">    var innerVar = &apos;b&apos;;</span><br><span class="line"></span><br><span class="line">    console.log(</span><br><span class="line">      &quot;outerArg = &quot; + outerArg + &quot;\n&quot; +</span><br><span class="line">      &quot;innerArg = &quot; + innerArg + &quot;\n&quot; +</span><br><span class="line">      &quot;outerVar = &quot; + outerVar + &quot;\n&quot; +</span><br><span class="line">      &quot;innerVar = &quot; + innerVar + &quot;\n&quot; +</span><br><span class="line">      &quot;globalVar = &quot; + globalVar);</span><br><span class="line"></span><br><span class="line">  &#125;)(456);</span><br><span class="line">&#125;)(123);</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中，来自于 innerFunc， outerFunc和全局命名空间的变量都在 innerFunc的范围内。因此，上面的代码将输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">outerArg = 123</span><br><span class="line">innerArg = 456</span><br><span class="line">outerVar = a</span><br><span class="line">innerVar = b</span><br><span class="line">globalVar = xyz</span><br></pre></td></tr></table></figure></p>
<h2 id="18-下面的代码将输出什么："><a href="#18-下面的代码将输出什么：" class="headerlink" title="18.下面的代码将输出什么："></a>18.下面的代码将输出什么：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">  setTimeout(function() &#123; console.log(i); &#125;, i * 1000 );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释你的答案。闭包在这里能起什么作用？</p>
<p>上面的代码不会按预期显示值0，1，2，3，和4，而是会显示5，5，5，5，和5。</p>
<p>原因是，在循环中执行的每个函数将整个循环完成之后被执行，因此，将会引用存储在 i中的最后一个值，那就是5。</p>
<p>闭包可以通过为每次迭代创建一个唯一的范围，存储范围内变量的每个唯一的值，来防止这个问题，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">	(function(x) &#123;</span><br><span class="line">    	setTimeout(function() &#123; console.log(x); &#125;, x * 1000 );</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就会按预期输出0，1，2，3，和4到控制台。</p>
<h2 id="19-以下代码行将输出什么到控制台？"><a href="#19-以下代码行将输出什么到控制台？" class="headerlink" title="19.以下代码行将输出什么到控制台？"></a>19.以下代码行将输出什么到控制台？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;0 || 1 = &quot;+(0 || 1));</span><br><span class="line">console.log(&quot;1 || 2 = &quot;+(1 || 2));</span><br><span class="line">console.log(&quot;0 &amp;&amp; 1 = &quot;+(0 &amp;&amp; 1));</span><br><span class="line">console.log(&quot;1 &amp;&amp; 2 = &quot;+(1 &amp;&amp; 2));</span><br></pre></td></tr></table></figure>
<p>并解释。</p>
<p>该代码将输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 || 1 = 1</span><br><span class="line">1 || 2 = 1</span><br><span class="line">0 &amp;&amp; 1 = 0</span><br><span class="line">1 &amp;&amp; 2 = 2</span><br></pre></td></tr></table></figure></p>
<p>在JavaScript中，<code>||</code>和<code>&amp;&amp;</code>都是逻辑运算符，用于在从左至右计算时，返回第一个可完全确定的“逻辑值”。</p>
<p>或（<code>||</code>）运算符。在形如<code>X||Y</code>的表达式中，首先计算X 并将其解释执行为一个布尔值。如果这个布尔值true，那么返回true（1），不再计算 Y，因为“或”的条件已经满足。如果这个布尔值为false，那么我们仍然不能知道 <code>X||Y</code>是真是假，直到我们计算 Y，并且也把它解释执行为一个布尔值。</p>
<p>因此， <code>0||1</code>的计算结果为true（1），同理计算<code>1||2</code>。</p>
<p>与（<code>&amp;&amp;</code>）运算符。在形如<code>X&amp;&amp;Y</code>的表达式中，首先计算 X并将其解释执行为一个布尔值。如果这个布尔值为 false，那么返回 false（0），不再计算 Y，因为“与”的条件已经失败。如果这个布尔值为true，但是，我们仍然不知道 <code>X&amp;&amp;Y</code>是真是假，直到我们去计算 Y，并且也把它解释执行为一个布尔值。</p>
<p>不过，关于<code>&amp;&amp;</code>运算符有趣的地方在于，当一个表达式计算为“true”的时候，那么就返回表达式本身。这很好，虽然它在逻辑表达式方面计算为“真”，但如果你希望的话也可用于返回该值。这就解释了为什么，有些令人奇怪的是， <code>1&amp;&amp;2</code>返回 2（而不是你以为的可能返回 true 或 1）。</p>
<h2 id="20-执行下面的代码时将输出什么？请解释。"><a href="#20-执行下面的代码时将输出什么？请解释。" class="headerlink" title="20.执行下面的代码时将输出什么？请解释。"></a>20.执行下面的代码时将输出什么？请解释。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(false == &apos;0&apos;)</span><br><span class="line">console.log(false === &apos;0&apos;)</span><br></pre></td></tr></table></figure>
<p>代码将输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p>
<p>在JavaScript中，有两种等式运算符。三个等于运算符<code>===</code>的作用类似传统的等于运算符：如果两侧的表达式有着相同的类型和相同的值，那么计算结果为true。而双等于运算符，会只强制比较它们的值。因此，总体上而言，使用<code>===</code>而不是<code>==</code>的做法更好。<code>!==</code>vs<code>!=</code>亦是同理。</p>
<h2 id="21-以下代码将输出什么？并解释你的答案。"><a href="#21-以下代码将输出什么？并解释你的答案。" class="headerlink" title="21.以下代码将输出什么？并解释你的答案。"></a>21.以下代码将输出什么？并解释你的答案。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a=&#123;&#125;,</span><br><span class="line">    b=&#123;key:&apos;b&apos;&#125;,</span><br><span class="line">    c=&#123;key:&apos;c&apos;&#125;;</span><br><span class="line"></span><br><span class="line">a[b]=123;</span><br><span class="line">a[c]=456;</span><br><span class="line"></span><br><span class="line">console.log(a[b]);</span><br></pre></td></tr></table></figure>
<p>这段代码将输出<code>456</code>（而不是<code>123</code>）。</p>
<p>原因为：当设置对象属性时，JavaScript会暗中字符串化参数值。在这种情况下，由于<code>b</code>和<code>c</code>都是对象，因此它们都将被转换为<code>&quot;[object Object]&quot;</code>。结果就是，<code>a[b]</code>和<code>a[c]</code>均相当于<code>a[&quot;[object Object]&quot;]</code>，并可以互换使用。因此，设置或引用<code>a[c]</code>和设置或引用<code>a[b]</code>完全相同。</p>
<h2 id="22-以下代码行将输出什么到控制台？"><a href="#22-以下代码行将输出什么到控制台？" class="headerlink" title="22.以下代码行将输出什么到控制台？"></a>22.以下代码行将输出什么到控制台？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log((function f(n)&#123;return ((n &gt; 1) ? n * f(n-1) : n)&#125;)(10));</span><br></pre></td></tr></table></figure>
<p>并解释你的答案。</p>
<p>代码将输出<code>10！</code>的值（即<code>10！</code>或<code>3628800</code>）。</p>
<p>原因是：</p>
<p>命名函数<code>f()</code>递归地调用本身，当调用<code>f(1)</code>的时候，只简单地返回<code>1</code>。下面就是它的调用过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f(1): returns n, which is 1</span><br><span class="line">f(2): returns 2 * f(1), which is 2</span><br><span class="line">f(3): returns 3 * f(2), which is 6</span><br><span class="line">f(4): returns 4 * f(3), which is 24</span><br><span class="line">f(5): returns 5 * f(4), which is 120</span><br><span class="line">f(6): returns 6 * f(5), which is 720</span><br><span class="line">f(7): returns 7 * f(6), which is 5040</span><br><span class="line">f(8): returns 8 * f(7), which is 40320</span><br><span class="line">f(9): returns 9 * f(8), which is 362880</span><br><span class="line">f(10): returns 10 * f(9), which is 3628800</span><br></pre></td></tr></table></figure></p>
<h2 id="23-请看下面的代码段。控制台将输出什么，为什么？"><a href="#23-请看下面的代码段。控制台将输出什么，为什么？" class="headerlink" title="23.请看下面的代码段。控制台将输出什么，为什么？"></a>23.请看下面的代码段。控制台将输出什么，为什么？</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function(x) &#123;</span><br><span class="line">    return (function(y) &#123;</span><br><span class="line">        console.log(x);</span><br><span class="line">    &#125;)(2)</span><br><span class="line">&#125;)(1);</span><br></pre></td></tr></table></figure>
<p>控制台将输出<code>1</code>，即使从来没有在函数内部设置过<code>x</code>的值。原因是：</p>
<p>闭包是一个函数，连同在闭包创建的时候，其范围内的所有变量或函数一起。在JavaScript中，闭包是作为一个“内部函数”实施的：即，另一个函数主体内定义的函数。闭包的一个重要特征是，内部函数仍然有权访问外部函数的变量。</p>
<p>因此，在本例中，由于<code>x</code>未在函数内部中定义，因此在外部函数范围中搜索定义的变量<code>x</code>，且被发现具有<code>1</code>的值。</p>
<h2 id="24-下面的代码将输出什么到控制台，为什么："><a href="#24-下面的代码将输出什么到控制台，为什么：" class="headerlink" title="24.下面的代码将输出什么到控制台，为什么："></a>24.下面的代码将输出什么到控制台，为什么：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var hero = &#123;</span><br><span class="line">    _name: &apos;John Doe&apos;,</span><br><span class="line">    getSecretIdentity: function ()&#123;</span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var stoleSecretIdentity = hero.getSecretIdentity;</span><br><span class="line"></span><br><span class="line">console.log(stoleSecretIdentity());</span><br><span class="line">console.log(hero.getSecretIdentity());</span><br></pre></td></tr></table></figure>
<p>代码有什么问题，以及应该如何修复。</p>
<p>代码将输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined</span><br><span class="line">John Doe</span><br></pre></td></tr></table></figure></p>
<p>第一个 <code>console.log</code>之所以输出<code>undefined</code>，是因为我们正在从<code>hero</code>对象提取方法，所以调用了全局上下文中（即窗口对象）的<code>stoleSecretIdentity()</code>，而在此全局上下文中， <code>_name</code>属性不存在。</p>
<p>其中一种修复<code>stoleSecretIdentity()</code>函数的方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var stoleSecretIdentity = hero.getSecretIdentity.bind(hero);</span><br></pre></td></tr></table></figure></p>
<h2 id="25-创建一个给定页面上的一个DOM元素，就会去访问元素本身及其所有子元素（不只是它的直接子元素）的函数。对于每个被访问的元素，函数应该传递元素到提供的回调函数。"><a href="#25-创建一个给定页面上的一个DOM元素，就会去访问元素本身及其所有子元素（不只是它的直接子元素）的函数。对于每个被访问的元素，函数应该传递元素到提供的回调函数。" class="headerlink" title="25.创建一个给定页面上的一个DOM元素，就会去访问元素本身及其所有子元素（不只是它的直接子元素）的函数。对于每个被访问的元素，函数应该传递元素到提供的回调函数。"></a>25.创建一个给定页面上的一个DOM元素，就会去访问元素本身及其所有子元素（不只是它的直接子元素）的函数。对于每个被访问的元素，函数应该传递元素到提供的回调函数。</h2><p>此函数的参数为：</p>
<ul>
<li>DOM元素</li>
<li>回调函数（将DOM元素作为其参数）</li>
</ul>
<p>访问树（DOM）的所有元素是经典的深度优先搜索算法应用。下面是一个示范的解决方案：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Traverse(p_element,p_callback) &#123;</span><br><span class="line">   p_callback(p_element);</span><br><span class="line">   var list = p_element.children;</span><br><span class="line">   for (var i = 0; i &lt; list.length; i++) &#123;</span><br><span class="line">       Traverse(list[i],p_callback);  // recursive call</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://yoursite.com/2019/02/12/25个最基本的JavaScript面试问题及答案/" data-id="cjvktybph006p44fvdl9h4nt3" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>关注我 :</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="twitter" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-twitter"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="facebook" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-facebook"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="google-plus" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-google-plus"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/ppoffice/hexo-theme-hueman" target="_blank" rel="noopener">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="weibo" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-weibo"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="rss" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-rss"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2019/02/12/用100行代码提升10倍的性能/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">下一篇</strong>
        <p class="article-nav-title">
        
            用100行代码提升10倍的性能
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2019/02/12/IP/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">上一篇</strong>
        <p class="article-nav-title">IP</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/05/12/JSP中include指令/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/05/12/JSP中include指令/8866.png)" alt="JSP中include指令" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/05/12/JSP中include指令/" class="title">JSP中include指令</a></p>
                            <p class="item-date"><time datetime="2019-05-12T10:52:42.000Z" itemprop="datePublished">2019-05-12</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/05/06/Chrome使用自定义协议打开本地程序/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/05/06/Chrome使用自定义协议打开本地程序/8550.jpg)" alt="Chrome使用自定义协议打开本地程序" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/05/06/Chrome使用自定义协议打开本地程序/" class="title">Chrome使用自定义协议打开本地程序</a></p>
                            <p class="item-date"><time datetime="2019-05-06T07:02:07.000Z" itemprop="datePublished">2019-05-06</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/04/27/有关ActiveXObject的兼容性问题（浏览器的特有属性）/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/04/27/有关ActiveXObject的兼容性问题（浏览器的特有属性）/867-1.png)" alt="有关ActiveXObject的兼容性问题（浏览器的特有属性）" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/04/27/有关ActiveXObject的兼容性问题（浏览器的特有属性）/" class="title">有关ActiveXObject的兼容性问题（浏览器的特有属性）</a></p>
                            <p class="item-date"><time datetime="2019-04-27T09:56:23.000Z" itemprop="datePublished">2019-04-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/04/26/如何用jQuery获得select的值/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/04/26/如何用jQuery获得select的值/056.png)" alt="如何用jQuery获得select的值" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/04/26/如何用jQuery获得select的值/" class="title">如何用jQuery获得select的值</a></p>
                            <p class="item-date"><time datetime="2019-04-26T03:23:16.000Z" itemprop="datePublished">2019-04-26</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/04/22/request可以得到哪些请求值/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/04/22/request可以得到哪些请求值/26&amp;gp=0.jpg)" alt="request可以得到哪些请求值" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/04/22/request可以得到哪些请求值/" class="title">request可以得到哪些请求值</a></p>
                            <p class="item-date"><time datetime="2019-04-22T08:31:14.000Z" itemprop="datePublished">2019-04-22</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/遥感/">遥感</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">二月 2019</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">30</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">29</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a><span class="archive-list-count">9</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/">PHP</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/h/">h</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript库/">javascript库</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/">maven</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/orcal/">orcal</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/冷知识/">冷知识</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/心语/">心语</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/舆论/">舆论</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目用到/">项目用到</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/Java/" style="font-size: 11px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 19px;">JavaScript</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/PHP/" style="font-size: 16px;">PHP</a> <a href="/tags/XML/" style="font-size: 11px;">XML</a> <a href="/tags/git/" style="font-size: 11px;">git</a> <a href="/tags/h/" style="font-size: 10px;">h</a> <a href="/tags/html/" style="font-size: 18px;">html</a> <a href="/tags/java/" style="font-size: 17px;">java</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/javascript库/" style="font-size: 20px;">javascript库</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/node/" style="font-size: 11px;">node</a> <a href="/tags/orcal/" style="font-size: 13px;">orcal</a> <a href="/tags/python/" style="font-size: 14px;">python</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/冷知识/" style="font-size: 12px;">冷知识</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/心语/" style="font-size: 12px;">心语</a> <a href="/tags/技术/" style="font-size: 12px;">技术</a> <a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/舆论/" style="font-size: 10px;">舆论</a> <a href="/tags/项目用到/" style="font-size: 10px;">项目用到</a>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://hexo.io">Hexo</a>
                    </li>
                
            </ul>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2019 陈义</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
            <div>
                <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                本站总访问量 <span id="busuanzi_value_site_pv"></span> 次&nbsp&nbsp&nbsp
                本站访客数<span id="busuanzi_value_site_uv"></span>人次
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

        
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'http://yoursite.com/2019/02/12/25个最基本的JavaScript面试问题及答案/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
