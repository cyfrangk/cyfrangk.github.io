<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">

    

    
    <title>JGroups入门 | 陈义的个人博客</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="java">
    
    <meta name="description" content="现在有很多项目都使用JGroups做底层的通讯，知道的开源项目有JBoss Cache和OSCache用它做为底层支持来实现集群的，一定还有其他的项目也用到了，只不过我不知道而已了。JGroups是一个开源的纯java编写的可靠的群组通讯工具。其工作模式基于IP多播，但可以在可靠性和群组成员管理上进行扩展。其结构上设计灵活，提供了一种灵活兼容多种协议的协议栈。JGroups 多线程的方式实现了多个">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="JGroups入门">
<meta property="og:url" content="http://yoursite.com/2019/07/14/JGroups入门/index.html">
<meta property="og:site_name" content="陈义的个人博客">
<meta property="og:description" content="现在有很多项目都使用JGroups做底层的通讯，知道的开源项目有JBoss Cache和OSCache用它做为底层支持来实现集群的，一定还有其他的项目也用到了，只不过我不知道而已了。JGroups是一个开源的纯java编写的可靠的群组通讯工具。其工作模式基于IP多播，但可以在可靠性和群组成员管理上进行扩展。其结构上设计灵活，提供了一种灵活兼容多种协议的协议栈。JGroups 多线程的方式实现了多个">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/07/14/JGroups入门/p=0.jpg">
<meta property="og:updated_time" content="2019-07-15T03:13:39.031Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JGroups入门">
<meta name="twitter:description" content="现在有很多项目都使用JGroups做底层的通讯，知道的开源项目有JBoss Cache和OSCache用它做为底层支持来实现集群的，一定还有其他的项目也用到了，只不过我不知道而已了。JGroups是一个开源的纯java编写的可靠的群组通讯工具。其工作模式基于IP多播，但可以在可靠性和群组成员管理上进行扩展。其结构上设计灵活，提供了一种灵活兼容多种协议的协议栈。JGroups 多线程的方式实现了多个">
<meta name="twitter:image" content="http://yoursite.com/2019/07/14/JGroups入门/p=0.jpg">
    

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/3.3.1/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    


</head>
</html>
<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">学而不思则罔，思而不学则殆</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item">
                                    <a class="main-nav-list-link" href="/">主页</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/推荐好文/">推荐好文</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/遥感/">遥感</a></li></ul>
                                    
                                <li class="main-nav-list-item">
                                    <a class="main-nav-list-link" href="/about/index.html">关于</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form" method="GET" action="https://www.baidu.com/s?">
    <input name="wd" type="text" class="search-form-input" placeholder="搜索">
</form>
<script>
(function ($) {
    $('.search-form').on('submit', function (e) {
        var keyword = $('.search-form-input[name="wd"]').val();
        window.location = 'https://www.baidu.com/s?wd=site:yoursite.com ' + keyword;
        return false;
    });
})(jQuery);
</script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    未分类
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-JGroups入门" class="article article-single article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        JGroups入门
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2019/07/14/JGroups入门/" class="article-date">
            <time datetime="2019-07-14T09:05:17.000Z" itemprop="datePublished">2019-07-14</time>
        </a>
    </div>

		

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <p>现在有<strong>很多项目都使用JGroups做底层的通讯</strong>，知道的开源项目有<code>JBoss Cache和OSCache</code>用它做为底层支持来实现集群的，一定还有其他的项目也用到了，只不过我不知道而已了。<br>JGroups是一个开源的纯java编写的可靠的群组通讯工具。其工作模式基于IP多播，但可以在可靠性和群组成员管理上进行扩展。其结构上设计灵活，提供了一种灵活兼容多种协议的协议栈。<br>JGroups 多线程的方式实现了多个协议之间的协同工作，常见工作线程有心跳检测，诊断等等。<br>JGroups实现多机器之间的通信一般都会包含维护群组状态、群组通信协议、群组数据可靠性传输这样的一些主题。<br>JGroups群组的各个节点是存在”管理节点”的，至少可以说某个节点提供了在一段时间内维护状态信息和消息可靠性检测的功能(一般是最先启动的节点)。<br>目前Jboss、Ecache的分布式缓存是基于Groups通信。<br><img src="/2019/07/14/JGroups入门/p=0.jpg" alt=""></p>
<h2 id="JGroups-适合使用场合"><a href="#JGroups-适合使用场合" class="headerlink" title="JGroups 适合使用场合"></a>JGroups 适合使用场合</h2><p>服务器集群cluster、多服务器通讯、服务器replication(复制)等，分布式cache缓存</p>
<h2 id="JGroups-简介"><a href="#JGroups-简介" class="headerlink" title="JGroups 简介"></a>JGroups 简介</h2><p>JGroups是一个基于Java语言的提供可靠多播(组播)的开发工具包。在IP Multicast基础上提供可靠服务，也可以构建在TCP或者WAN上。主要是由Bela Ban开发，属于JBoss.org，在JBoss的网站也有一些相关文档。目前在 SourceForge上还是比较活跃，经常保持更新。</p>
<p>若JGroups通信基于Udp，则可能需要开启机器上UDP相关的设置，比如Open udp。<br>温馨提示：JGroups各个协议相关的配置文件都可以从JGroups-x.x.x.Final.jar中找到。</p>
<h2 id="JGroups-资料"><a href="#JGroups-资料" class="headerlink" title="JGroups 资料"></a>JGroups 资料</h2><p><a href="http://www.jgroups.org/tutorial/index.html(官网)" target="_blank" rel="noopener">http://www.jgroups.org/tutorial/index.html(官网)</a><br> <a href="http://sourceforge.net/projects/javagroups/(JGroups工程&amp;讨论组(Discussion)" target="_blank" rel="noopener">http://sourceforge.net/projects/javagroups/(JGroups工程&amp;讨论组(Discussion)</a>)</p>
<p>JGroups是一个可靠的组间通讯工具，进程可以加入一个通讯组，给组内所有的成员或单独的成员发送消息，同样，也可以从组中的成员处接收消息。系统会记录组的每一个成员，在新成员加入或是现有的成员离开或是崩溃时，会通知组内的其他成员，这样我们就不必自己去管理这些事情了。 </p>
<p>要想加入一个组，并与组内其他的成员交互，必须建立一个Channel连接到组，同一个组内的所有成员使用相同的组名称。首先是创建一个Channel，可以直接实例化一个Channel的实现，这里用的是JChannel： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JChannel channel = new JChannel(props);</span><br></pre></td></tr></table></figure>
<p>参数里指定Channel使用的协议栈，如果是空的，则使用默认的协议栈，位于JGroups包里的udp.xml。参数可以是一个以冒号分隔的字符串，或是一个XML文件，在XML文件里定义协议栈。 </p>
<p>下面的是JGroups文档里给出的字符串的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String props=&quot;UDP(mcast_addr=228.1.2.3;mcast_port=45566;ip_ttl=32):&quot; +  </span><br><span class="line">        &quot;PING(timeout=3000;num_initial_members=6):&quot; +  </span><br><span class="line">        &quot;FD(timeout=5000):&quot; +  </span><br><span class="line">        &quot;VERIFY_SUSPECT(timeout=1500):&quot; +  </span><br><span class="line">        &quot;pbcast.STABLE(desired_avg_gossip=10000):&quot; +  </span><br><span class="line">        &quot;pbcast.NAKACK(gc_lag=10;retransmit_timeout=3000):&quot; +  </span><br><span class="line">        &quot;UNICAST(timeout=5000;min_wait_time=2000):&quot; +  </span><br><span class="line">        &quot;FRAG:&quot; +  </span><br><span class="line">        &quot;pbcast.GMS(initial_mbrs_timeout=4000;join_timeout=5000;&quot; +  </span><br><span class="line">        &quot;join_retry_timeout=2000;shun=false;print_local_addr=false)&quot;;  </span><br><span class="line">JChannel channel;  </span><br><span class="line">try &#123;  </span><br><span class="line">    channel=new JChannel(props);  </span><br><span class="line">&#125;  </span><br><span class="line">catch(Exception ex) &#123;  </span><br><span class="line">// channel creation failed</span><br></pre></td></tr></table></figure></p>
<p>创建完之后，Channel现在处于未连接状态，需要通过connect方法将之连接到组，使其处于连接状态： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void connect(String groupname) throws ChannelClosed;</span><br></pre></td></tr></table></figure>
<p>它的参数就是要加入组的组名字，如果加入的组之前没有任何成员，则会自动创建一个组。<br>此时，Channel已处于连接状态，可以发送/接收消息了，发送消息的方法为： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void send(Message msg) throws ChannelNotConnected, ChannelClosed;  </span><br><span class="line">public void send(Address dst, Address src, Object obj) throws ChannelNotConnected, ChannelClosed;</span><br></pre></td></tr></table></figure>
<p>两个方法基本是一样的，只不过一个是直接提供一个消息，而另一个只是提供了消息的目的地，源，和消息内容，其实这个方法在内部也是通过第一个方法来实现的，在其内部，将提供的这三个参数组合成一个消息，再调用第一个方法，具体使用哪个方法，则看个人喜好和实际情况了。 </p>
<p>消息的由消息的目的地，源，Flag，消息内容，Header组成。其中如果目的地为空，则认为是发给所有组成员的消息；源为空的话，在底层的协议将其放到网络上时，会自动的将本Channel的地址填充进去。Address则是组成员的地址，用于唯一的标识一个组成员的接口，JGroups提供了几种默认的实现。下面的例子是发送一条消息到组内所有的成员处： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Hashtable data; // any serializable data  </span><br><span class="line">try &#123;  </span><br><span class="line">    channel.send(null, null, data);  </span><br><span class="line">&#125;catch(Exception ex) &#123;</span><br><span class="line">	// handle errors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来一个发送到单独的组成员的例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Address receiver;  </span><br><span class="line">Hashtable data;  </span><br><span class="line">try &#123;  </span><br><span class="line">	receiver=channel.getView().getMembers().first();  </span><br><span class="line">	channel.send(receiver, null, data);  </span><br><span class="line">&#125;catch(Exception ex) &#123;  </span><br><span class="line">	// handle errors  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>其中的channel.getView().getMembers().first()是指从Channel中取出当前的成员列表，再从中取出第一个成员。之后就可以将这个成员做为目的地来发送消息了</code>。 </p>
<p>可以发送消息，同样也可以接收消息： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Object receive(long timeout) throws ChannelNotConnected, ChannelClosed, Timeout;</span><br></pre></td></tr></table></figure>
<p>利用此方法可以取回多种消息，如普通的消息，View消息，等等。它的timeout参数则是指定超时的时间，如果设置为0时，而此时又没有新消息可以接收，此方法则会形成一个阻塞，在这一直等到有可用的消息为止；设置为大于0时，如果没有可用消息，超过此值后，会抛出一个Timeout异常。 </p>
<p>下面的列表则是可以接收的消息的详细清单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Message  </span><br><span class="line">View  </span><br><span class="line">SuspectEvent  </span><br><span class="line">BlockEvent  </span><br><span class="line">UnblockEvent  </span><br><span class="line">GetStateEvent  </span><br><span class="line">StreamingGetStateEvent  </span><br><span class="line">SetStateEvent  </span><br><span class="line">StreamingSetStateEvent</span><br></pre></td></tr></table></figure></p>
<p>同样，也给出一个此方法的应用小例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Object obj;  </span><br><span class="line">Message msg;  </span><br><span class="line">View v;  </span><br><span class="line">obj=channel.receive(0); // wait forever  </span><br><span class="line">if(obj instanceof Message)&#123; </span><br><span class="line">	msg=(Message)obj;</span><br><span class="line">&#125;else if(obj instanceof View)&#123;  </span><br><span class="line">	v=(View)obj; </span><br><span class="line">&#125;else&#123;</span><br><span class="line">;</span><br><span class="line">&#125;  </span><br><span class="line">// don&apos;t handle suspicions or blocks</span><br></pre></td></tr></table></figure>
<p>receive()方法是Channel主动的去取消息，这种方式在现在的JGroups版本中已经不赞成被使用了，而替代方式则是通过setReceiver()方法向Channel注册一个监听器，在有消息到达的时候，自动的调用相应的方法来处理消息。 </p>
<p>setReceiver()方法的参数是一个Receiver接口，此接口继承了MessageListener和MembershipListener，呵，看名字就知道这两个Listener是做什么的了。JGroups里提供了一个Receiver的Adapter：ReceiverAdapter，它只是为Receiver接口里的方法提供了一空的实现，可以让我们在自己的实现中只需实现关心的方法就OK了。下面是一个用注册Receiver的形式接收消息的实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JChannel ch=new JChannel();  </span><br><span class="line">ch.setReceiver(new ReceiverAdapter() &#123;  </span><br><span class="line">    public void receive(Message msg) &#123;  </span><br><span class="line">        System.out.println(&quot;received message &quot; + msg);  </span><br><span class="line">    &#125;  </span><br><span class="line">    public void viewAccepted(View new_view) &#123;  </span><br><span class="line">        System.out.println(&quot;received view &quot; + new_view);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);  </span><br><span class="line">ch.connect(&quot;bla&quot;);</span><br></pre></td></tr></table></figure>
<p>利用上面的的两种方式接收消息时，会将接收到的消息从消息队列中删除，如果只是想了解一下下一条消息，而又不想将它从消息队列中删除时，可以使用peek()方法，它的使用方式同receive()。</p>
<p>了解了如果发送和接收消息之后，现在Channel想转移到未连接状态啦，可以使用disconnect()，将Channel与组断开连接，这个时候如果再执行发送或接收消息的操作的话，那就等着接收异常吧，呵。 </p>
<p>Channel处于未连接状态之后，可以重新连接到组，也可以通过close()方法关闭Channel，需要注意的是，执行了close()之后，就不能直接执行connect()方法来使Channel连接到组了，需要使用open()来将Channel重新打开，之后再能与组进行连接。 </p>
<p>上面只是对JGroups的简单应用做一下整理，其实这只是JGroups的皮毛而已，JGroups还包含很多内容：状态传递，Building Blocks(OSCache使用的就是Building Blocks里的NotificationBus)，还有协议栈等等好多内容，这些还得慢慢的继续学习啊。</p>
<p>转自：<a href="http://www.iteye.com/topic/81783" target="_blank" rel="noopener">http://www.iteye.com/topic/81783</a></p>
<p>JGroups使用例子, JGroups demo, Tim的hello world例子<br>Timreceiver.java<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">import org.jgroups.tests.perf.Receiver;</span><br><span class="line">import org.jgroups.tests.perf.Transport;</span><br><span class="line">import org.jgroups.util.Util;</span><br><span class="line"></span><br><span class="line">public class TimReceiver implements Receiver &#123;</span><br><span class="line">	private Transport transport = null;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		TimReceiver t = new TimReceiver();</span><br><span class="line">		try &#123;</span><br><span class="line">			int sendMsgCount = 5000;</span><br><span class="line">			int msgSize = 1000;</span><br><span class="line">			t.start();</span><br><span class="line"></span><br><span class="line">			t.sendMessages(sendMsgCount, msgSize);</span><br><span class="line">			System.out.println(&quot;########## Begin to recv...&quot;);</span><br><span class="line">			Thread.currentThread().join();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			if (t != null) &#123;</span><br><span class="line">				t.stop();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void start()</span><br><span class="line">	throws Exception &#123;</span><br><span class="line">		transport = (Transport) new TimTransport();</span><br><span class="line">		transport.create(null);</span><br><span class="line">		transport.setReceiver(this);</span><br><span class="line">		transport.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		if (transport != null) &#123;</span><br><span class="line">			transport.stop();</span><br><span class="line">			transport.destroy();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private int count = 0;</span><br><span class="line">	public void receive(Object sender, byte[] data) &#123;</span><br><span class="line">		System.out.print(&quot;.&quot;);</span><br><span class="line">		if (++count == 5000) &#123;</span><br><span class="line">			System.out.println(&quot;\r\nRECV DONE.&quot;);</span><br><span class="line">			System.exit(0);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private void sendMessages(int count, int msgSize)throws Exception &#123;</span><br><span class="line">		byte[] buf = new byte[msgSize];</span><br><span class="line">		for (int k = 0; k &lt; msgSize; k++)&#123;</span><br><span class="line">			buf[k] = &apos;T&apos;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;-- sending &quot; + count + &quot; &quot; + Util.printBytes(msgSize) + &quot; messages&quot;);</span><br><span class="line"></span><br><span class="line">		for (int i = 0; i &lt; count; i++) &#123;</span><br><span class="line">			transport.send(null, buf);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;######### send complete&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>TimTransport.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Map;</span><br><span class="line">import java.util.Properties;</span><br><span class="line"></span><br><span class="line">import org.jgroups.Address;</span><br><span class="line">import org.jgroups.JChannel;</span><br><span class="line">import org.jgroups.Message;</span><br><span class="line">import org.jgroups.ReceiverAdapter;</span><br><span class="line">import org.jgroups.tests.perf.Receiver;</span><br><span class="line">import org.jgroups.tests.perf.Transport;</span><br><span class="line"></span><br><span class="line">public class TimTransport extends ReceiverAdapter implements Transport&#123;</span><br><span class="line">	private JChannel channel = null;</span><br><span class="line">	private String groupName = &quot;TimDemo&quot;;</span><br><span class="line">	private Receiver receiver = null;</span><br><span class="line"></span><br><span class="line">	String PROTOCOL_STACK_UDP1 = &quot;UDP(bind_addr=192.168.100.59&quot;; </span><br><span class="line">	String PROTOCOL_STACK_UDP2 = &quot;;mcast_port=8888&quot;;</span><br><span class="line">	String PROTOCOL_STACK_UDP3 = &quot;;mcast_addr=225.1.1.1&quot;;</span><br><span class="line">	String PROTOCOL_STACK_UDP4 = &quot;;tos=8;loopback=false;max_bundle_size=64000;&quot; +</span><br><span class="line">		&quot;use_incoming_packet_handler=true;use_outgoing_packet_handler=false;ip_ttl=2;enable_bundling=true):&quot;</span><br><span class="line">		+ &quot;PING:MERGE2:FD_SOCK:FD:VERIFY_SUSPECT:&quot;</span><br><span class="line">		+&quot;pbcast.NAKACK(gc_lag=50;max_xmit_size=50000;use_mcast_xmit=false;&quot; +</span><br><span class="line">		&quot;retransmit_timeout=300,600,1200,2400,4800;discard_delivered_msgs=true):&quot;</span><br><span class="line">		+&quot;UNICAST:pbcast.STABLE:VIEW_SYNC:&quot;</span><br><span class="line">		+&quot;pbcast.GMS(print_local_addr=false;join_timeout=3000;&quot; +</span><br><span class="line">		&quot;join_retry_timeout=2000;&quot; +</span><br><span class="line">		&quot;shun=true;view_bundling=true):&quot;</span><br><span class="line">		+&quot;FC(max_credits=2000000;min_threshold=0.10):FRAG2(frag_size=50000)&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public Object getLocalAddress() &#123;</span><br><span class="line">		return channel != null ? channel.getLocalAddress() : null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void start() throws Exception &#123;</span><br><span class="line">		channel.connect(groupName); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		if (channel != null) &#123;</span><br><span class="line">			channel.shutdown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">		if (channel != null) &#123;</span><br><span class="line">			channel.close();</span><br><span class="line">			channel = null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setReceiver(Receiver r) &#123;</span><br><span class="line">		this.receiver = r;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Map dumpStats() &#123;</span><br><span class="line">		return channel != null ? channel.dumpStats() : null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void send(Object destination, byte[] payload) throws Exception &#123;</span><br><span class="line">		byte[] tmp = new byte[payload.length];</span><br><span class="line">		System.arraycopy(payload, 0, tmp, 0, payload.length);</span><br><span class="line">		Message msg = null;</span><br><span class="line">		msg = new Message((Address) destination, null, tmp);</span><br><span class="line">		if (channel != null) &#123;</span><br><span class="line">			channel.send(msg);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void receive(Message msg) &#123;</span><br><span class="line">		Address sender = msg.getSrc();</span><br><span class="line">		byte[] payload = msg.getBuffer();</span><br><span class="line">		if (receiver != null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				receiver.receive(sender, payload);</span><br><span class="line">			&#125; catch (Throwable tt) &#123;</span><br><span class="line">				tt.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void create(Properties config) throws Exception &#123;</span><br><span class="line">		String PROTOCOL_STACK = PROTOCOL_STACK_UDP1 + PROTOCOL_STACK_UDP2 + PROTOCOL_STACK_UDP3 + PROTOCOL_STACK_UDP4;</span><br><span class="line">		channel = new JChannel(PROTOCOL_STACK);</span><br><span class="line">		channel.setReceiver(this); </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void send(Object destination, byte[] payload, boolean oob) throws Exception &#123;</span><br><span class="line">		send(destination, payload);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转自<a href="http://jportal.iteye.com/blog/359520" target="_blank" rel="noopener">http://jportal.iteye.com/blog/359520</a></p>
<h1 id="JGroups-应用示例"><a href="#JGroups-应用示例" class="headerlink" title="JGroups 应用示例"></a>JGroups 应用示例</h1><h2 id="一个简单的基于文本的聊天程序-SimpleChat"><a href="#一个简单的基于文本的聊天程序-SimpleChat" class="headerlink" title="一个简单的基于文本的聊天程序(SimpleChat)"></a>一个简单的基于文本的聊天程序(SimpleChat)</h2><p>包含如下功能：</p>
<ul>
<li>所有 SimpleChat 的实例通过一个组来查找彼此</li>
<li>无需运行一个中央的聊天服务器来供 SimpleChat 连接，因此也就没有单点故障</li>
<li>聊天信息将发送给组中的所有成员</li>
<li>当某个实例离开或者加入组或者崩溃时，其他的成员会收到通知</li>
<li>(可选) 我们维护一个公用的组范围内的状态分享，例如聊天历史记录。新的实例可从已有的实例处获取这些历史记录</li>
</ul>
<h2 id="JGroups-概要"><a href="#JGroups-概要" class="headerlink" title="JGroups 概要"></a>JGroups 概要</h2><p>JGroups 使用 JChannel 作为连接到组、发送和接收消息的主 API，并可通过 JChannel 注册用来处理这些事件（成员加入、退出和发送消息）的侦听器。</p>
<p>而 Messages 是发送的消息，它包含一个字节缓冲区、发送和接受者地址。Addresses 是 org.jgroups.Address 的子类，通常包含一个 IP 地址和端口。</p>
<p>组中的实例列表被成为 View，每个实例包含相同的 View，可通过 View.getMembers() 来获取所有实例的地址列表。</p>
<p>实例 Instances 只能在加入组后才能发送和接收消息。</p>
<p>当一个实例要离开组时，JChannel.disconnect() 或者 JChannel.close() 方法会被调用，后者实际上会判断当连接还保持时调用了 disconnect() 方法来关闭通道。</p>
<h2 id="创建并加入组通道"><a href="#创建并加入组通道" class="headerlink" title="创建并加入组通道"></a>创建并加入组通道</h2><p>要加入一个组，我需要使用 JChannel。一个 JChannel 的实例可以通过一个配置来创建，配置中定义了通道的属性。然后通过 connect(String clustername) 来连接到组中。所有通道实例都是调用 connect() 并使用相同的参数来加入相同的组中。下面让我们实际创建一个 JChannel 并连接到名为 ChatCluster 的组中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import org.jgroups.JChannel;</span><br><span class="line"></span><br><span class="line">public class SimpleChat &#123;</span><br><span class="line"></span><br><span class="line">    JChannel channel;</span><br><span class="line">    String user_name=System.getProperty(&quot;user.name&quot;, &quot;n/a&quot;);</span><br><span class="line"></span><br><span class="line">    private void start() throws Exception &#123;</span><br><span class="line">        channel=new JChannel(); // use the default config, udp.xml</span><br><span class="line">        channel.connect(&quot;ChatCluster&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new SimpleChat().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先我们使用空的构造器来创建一个 JChannel 实例，该方法使用默认的配置。你也可以传递一个 XML 文件来配置这个 JChannel，例如 new JChannel(“/home/bela/udp.xml”).</p>
<p>connect() 方法加入 ChatCluster 组中。注意我们并不需要事先明确的创建一个组，connect() 方法会判断如果是组中的第一个实例时自动创建该组。之后其他的实例连接过来就加入了相同的组，例如：</p>
<ul>
<li>ch1 joining “cluster-one”</li>
<li>ch2 joining “cluster-two”</li>
<li>ch3 joining “cluster-two”</li>
<li>ch4 joining “cluster-one”</li>
<li>ch5 joining “cluster-three”<br>这样我们就有三个组：”cluster-one” 包含 ch1 和 ch4, “cluster-two” 包含 ch2 和 ch3, 而 “cluster-three” 只有一个 ch5 实例.</li>
</ul>
<h2 id="主事件循环和发送聊天消息"><a href="#主事件循环和发送聊天消息" class="headerlink" title="主事件循环和发送聊天消息"></a>主事件循环和发送聊天消息</h2><p>现在我们运行一个事件循环来从标准控制台输入中读取文本消息，然后发送到组中所有成员。当输入 exit 或者 quit 命令时，将会退出循环并关闭通道<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void start() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    channel=new JChannel();</span><br><span class="line">    channel.connect(&quot;ChatCluster&quot;);</span><br><span class="line">    eventLoop();</span><br><span class="line">    channel.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void eventLoop() &#123;</span><br><span class="line"></span><br><span class="line">    BufferedReader in=new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line"></span><br><span class="line">    while(true) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.print(&quot;&gt; &quot;); System.out.flush();</span><br><span class="line">            String line=in.readLine().toLowerCase();</span><br><span class="line">            if(line.startsWith(&quot;quit&quot;) || line.startsWith(&quot;exit&quot;))</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            line=&quot;[&quot; + user_name + &quot;] &quot; + line;</span><br><span class="line">            Message msg=new Message(null, null, line);</span><br><span class="line">            channel.send(msg);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        catch(Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这里添加了 eventLoop() 的调用，然后关闭通道的方法。</p>
<p>事件处理循环当输入回车时就会发送消息到组中，这是通过构造一个新的 Message 实例然后调用 Channel.send() 方法来发送。</p>
<p>Message 类构造器的首个参数是目标地址，该参数设置为 null 表示将发送给组中所有成员（非空的参数表示要发送到指定的某个成员）。</p>
<p>第二个参数是发送者的地址，这也是 null，JGroups 会自动使用当前的恰当的地址。</p>
<p>第三个参数是我们从标准控制台输入中读到的键盘输入的内容，这个内容会通过 Java 的序列化机制变成 byte[] 数据并设置为 Message 的内容。注意我们也可以自己来序列化一个对象（而且也推荐这样做），然后给 Message 构造器第三个参数传递 byte[] 值。</p>
<p>到这里应用程序功能就已差不多完整，不过还缺少一样，没有对接收到的消息进行提醒和显示，接下来我们介绍消息的接收。</p>
<h2 id="接收消息并查看更改通知"><a href="#接收消息并查看更改通知" class="headerlink" title="接收消息并查看更改通知"></a>接收消息并查看更改通知</h2><p>现在我们要注册一个 Receiver 来接收消息并查看组中成员的变动。我们可以实现 org.jgroups.Receiver，不过这里我选用直接继承 ReceiverAdapter 类，因为该类已经有一些默认的实现方法了。然后只需要重载回调函数 receive() 和 viewChange() 即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class SimpleChat extends ReceiverAdapter &#123;</span><br></pre></td></tr></table></figure></p>
<p>设置接收器的 start() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void start() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    channel=new JChannel();</span><br><span class="line">    channel.setReceiver(this);</span><br><span class="line">    channel.connect(&quot;ChatCluster&quot;);</span><br><span class="line">    eventLoop();</span><br><span class="line">    channel.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现 receive() 和 viewAccepted() 方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void viewAccepted(View new_view) &#123;</span><br><span class="line">    System.out.println(&quot;** view: &quot; + new_view);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public void receive(Message msg) &#123;</span><br><span class="line">    System.out.println(msg.getSrc() + &quot;: &quot; + msg.getObject());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>viewAccepted() 回调函数会在新成员加入组中，或者已有成员崩溃了或离开组时被调用。其 toString() 方法会打印 View ID（也就是成员ID）以及当前成员列表。</p>
<p>在 receive() 方法中我们可以得到一个 Message 的参数，只需要读取其缓冲区内容并输出到控制台，同时我们也把发送者的地址打印出来 (Message.getSrc()).</p>
<p>注意我们也可以通过调用 Message.getBuffer() 来获取消息实体中的 byte[] 数据然后通过自己的反序列化来处理，例如 String line=new String(msg.getBuffer()).</p>
<h2 id="测试-SimpleChat-程序"><a href="#测试-SimpleChat-程序" class="headerlink" title="测试 SimpleChat 程序"></a>测试 SimpleChat 程序</h2><p>现在我们这个演示程序的所有功能均已完成，可使用如下命令来运行试试（译者注：请自行将 jgroup-xxx.jar 添加到类路径）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[linux]/home/bela$ java SimpleChat</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">GMS: address=linux-48776, cluster=ChatCluster, physical address=192.168.1.5:42442</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">** view: [linux-48776|0] [linux-48776]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们启动的实例名是 linux-48776 ，其物理地址是 192.168.1.5:42442 (IP address:port). 这个名字是由 JGroups 来生成的（如果用户没有设置的话，通常是主机名加一个随机的数字），该名字一直存在并在整个生命周期中保持不变，同时映射到一个基础的 UUID，而 UUID 映射到物理地址。</p>
<p>接下来启动第二个实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[linux]/home/bela$ java SimpleChat</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">GMS: address=linux-37238, cluster=ChatCluster, physical address=192.168.1.5:40710</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">** view: [linux-48776|1] [linux-48776, linux-37238]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<p>现在组中有两个成员，包括 [linux-48776, linux-37238], 这里显示的是加入组中两个成员的名称。注意第一个成员 (linux-48776) 同样也接收到相同的 view，因此两个成员包含了同样的成员列表，顺序也一致。实例是根据加入组中的先后顺序列表的，因此最早加入的成员排在最前面。</p>
<p>只需要输入消息并按回车键就可以发送消息。消息被发送到组中，因此组中所有成员都将接收到该消息，包括发送者自己。</p>
<p>当输入 exit 或者 quit 并按回车，实例将会退出组。</p>
<p>为了模拟成员崩溃的情况（例如在控制台中按 Ctrl + C），其他的幸存者将接收到一个新的 view ，而当前的组中只有一个成员。</p>
<h2 id="额外信息：维护共享的组数据"><a href="#额外信息：维护共享的组数据" class="headerlink" title="额外信息：维护共享的组数据"></a>额外信息：维护共享的组数据</h2><p>JGroups 另外一个使用场景是可以帮你维护一份可在组中共享的数据。例如，Web 服务器中的所有 HTTP 会话。如果这些会话通过组来复制，那么客户端就可以访问组中的任意成员来获得这些数据，就算某个成员崩溃或者退出了，这些数据依然可用。</p>
<p>对会话的更新也会通过组进行复制，例如某个序列化属性被修改了，那么其他成员也会得知这个修改，这样就使得组中所有成员包含了相同的状态。</p>
<p>可当组中加入一个新成员会怎么样呢？新加入的成员必须通过某些方法来获取这些状态数据，这被称为是“状态传输”。</p>
<p>JGroups 的状态传输是通过两个回调函数来实现的 (getState() and setState()) ，我们需要调用 getState() 方法来获取状态数据。注意，为了在应用中使用状态传输，协议堆栈必须有一个状态传输协议（我们这个演示程序使用了默认的堆栈）。</p>
<p>我们修改一下 start() 方法，加入 getState() 的调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void start() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    channel=new JChannel();</span><br><span class="line">    channel.setReceiver(this);</span><br><span class="line">    channel.connect(&quot;ChatCluster&quot;);</span><br><span class="line">    channel.getState(null, 10000);</span><br><span class="line">    eventLoop();</span><br><span class="line">    channel.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getState() 方法第一个参数是目标成员，null 表示首个成员（协调者）。第二个参数是超时时间，这里我们设置了 10 秒钟的超时时间，意味着状态传输的时间必须在 10 秒内完成，否则将会抛出异常，0 代表没有超时时间。<br>ReceiverAdapter 定义了 getState() 回调函数，当组中实例（一般是第一个实例，或者也叫协调者）收到一个已有实例要获取组状态时被调用。在我们的示例程序中，我们为聊天会话定义了一个状态，这是一个简单的列表，包含最新的几条聊天信息（这个可能不是一个好的组状态的例子，因为这个状态数据一直在增长).</p>
<p>聊天信息列表并定义为实例变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final List&lt;String&gt; state=new LinkedList&lt;String&gt;();</span><br></pre></td></tr></table></figure></p>
<p>我们还需要修改 receive() 方法来将接收到的消息追加到状态数据中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void receive(Message msg) &#123;</span><br><span class="line">    String line=msg.getSrc() + &quot;: &quot; + msg.getObject();</span><br><span class="line">    System.out.println(line);</span><br><span class="line">    synchronized(state) &#123;</span><br><span class="line">        state.add(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getState() 回调函数实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void getState(OutputStream output) throws Exception &#123;</span><br><span class="line">    synchronized(state) &#123;</span><br><span class="line">        Util.objectToStream(state, new DataOutputStream(output));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getState() 方法在 “状态提供者” 里调用，当实例返回状态数据后会被转换成输出流。JGroups 会在状态数据写入完毕后关闭流，就算有异常发送也会这样，因此你不需要自己来关闭流。</p>
<p>因为访问状态数据可能是并发的，我们必须做同步控制。然后调用 Util.objectToStream() 这个工具方法来将对象写入流中。</p>
<p>setState() 方法在“状态请求者”处调用，也就是调用了 getState() 方法的成员上，其任务就是从输入流中读取状态数据并保存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public void setState(InputStream input) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list;</span><br><span class="line">    list=(List&lt;String&gt;)Util.objectFromStream(new DataInputStream(input));</span><br><span class="line"></span><br><span class="line">    synchronized(state) &#123;</span><br><span class="line">        state.clear();</span><br><span class="line">        state.addAll(list);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(list.size() + &quot; messages in chat history):&quot;);</span><br><span class="line"></span><br><span class="line">    for(String str: list) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再一次调用 JGroups 工具方法 (Util.objectFromStream()) 来从输入流中创建一个对象，然后对 state 同步并赋值。</p>
<p>在接收完状态数据后，我们打印了状态数据中的聊天信息数。注意这里并没有处理超大列表的情况，可能会发生不可预知的问题。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这部分展示了如何创建、加入和离开组，并给组成员发送和接收消息，获取组成员的变化情况，同时实现了状态的传输。所有这些都是通过 JGroups 的核心 API —— JChannel 和 Receiver 提供的。<br>还有两个关于 JGroups 方面的内容没有涉及到的，分别是：构建块 (Building blocks) 和协议堆栈。<br>构建块是一些类继承自 JChannel 提供了更高级别的抽象层，例如请求响应、组范围内的方法调用、复制哈希等等。<br>而协议堆栈允许对 JGroups 底层通讯协议进行定制，包括配置、移除、增强或者重写全新的协议。<br>SimpleChat 的代码可从 这里 获取。<br>这里还有一些其他 JGroups 相关的资料：</p>
<ul>
<li>SimpleChat code: <a href="http://www.jgroups.org/tutorial/code/SimpleChat.java" target="_blank" rel="noopener">SimpleChat.java</a></li>
<li>JGroups web site: <a href="http://www.jgroups.org" target="_blank" rel="noopener">http://www.jgroups.org</a></li>
<li>Downloads: <a href="https://sourceforge.net/projects/javagroups/files/JGroups/" target="_blank" rel="noopener">here</a></li>
<li>JIRA bug tracking: <a href="http://jira.jboss.com/jira/browse/JGRP" target="_blank" rel="noopener">http://jira.jboss.com/jira/browse/JGRP</a></li>
<li>Mailing lists: <a href="http://sourceforge.net/mail/?group_id=6081" target="_blank" rel="noopener">http://sourceforge.net/mail/?group_id=6081</a></li>
</ul>
<h1 id="一个分布式任务分发系统"><a href="#一个分布式任务分发系统" class="headerlink" title="一个分布式任务分发系统"></a>一个分布式任务分发系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JGroups 是一个集群通讯类库，应用可以用JGroups<br>加入一个集群，发送消息给集群中的其他节点。同时也可以在集群节点离开或者加入集群的时候获得通知（包括节点崩溃）.<br>JGroups 的任务是提供可靠的消息发送机制，它和JMS不同，它不关心，消息主题，队列等。<br>JGroups 最主要的特点是支持灵活多变的协议栈配置。应用可以按照自己的喜好将配置编辑到一个XML文件中。比如，应用可以很容易的实现压缩协议的配置。<br>或者它可以删除碎片，因为它的消息总是小于65K(超过UDP)，或者因为它使用TCP作为传输<br>另一个应用程序可能会添加加密和身份验证，因此消息是加密的，只有节点表示有效的X.509证书可以加入集群。<br>应用程序甚至可以自由地编写自己的协议(或扩展现有的协议)，并将它们添加到配置中。例如，为了审计或统计数据，添加一个跟踪所有发送和接收到的消息的协议。</p>
<p>JGroups 架构图<br><img src="/2019/07/14/JGroups入门/849c8fb.gif" alt=""><br>客户端的主要API是Channal,它用于发送和接收消息。</p>
<p>当消息发送以后，它将陪投递到协议栈，堆栈是一个协议列表，每个协议都有机会对消息进行处理。</p>
<p>例如，分段协议可能检查消息的大小。如果消息大于配置的大小，则可能将其分割为多个较小的消息，并将其发送到堆栈中。</p>
<p>在接收端，分段协议将对片段进行排队，直到接收到所有的片段，然后将它们组合到原始消息中并将其传递下去。</p>
<h2 id="JGroups附带的协议可以划分为以下类别："><a href="#JGroups附带的协议可以划分为以下类别：" class="headerlink" title="JGroups附带的协议可以划分为以下类别："></a>JGroups附带的协议可以划分为以下类别：</h2><ul>
<li>传输:发送和接收消息。UDP使用IP多播和/或UDP数据报。TCP使用TCP连接。</li>
<li>发现:节点的初始发现</li>
<li>合并:在网络分区恢复后，将子集群合并回一个分区</li>
<li>故障检测:监视集群节点和潜在崩溃或挂起的通知</li>
<li>可靠性:确保消息不会丢失，只接收一次，并按照发送方发送的顺序接收。这是通过为每个消息分配序列号，并通过在消息丢失的情况下重新传输来完成的。</li>
<li>稳定性:节点必须缓冲所有消息(用于重新传输)。稳定协议确保定期(或基于累积的大小)，清除所有集群节点接收到的消息，这样它们就可以实现垃圾回收。</li>
<li>组成员管理:跟踪集群中的节点，并通知应用节点的加入或离开(包括崩溃)</li>
<li>流量控制:确保发送者不能发送消息的速度超过接收方在的处理速度。这是防止内存溢出的必要条件。</li>
<li>分段:将大型消息片段分割为较小的消息，并在接收方重新组装</li>
<li>状态传输:确保集群的共享状态(例如，所有HTTP会话)被正确地转移到一个新节点</li>
<li>压缩:压缩消息并在接收方对其进行减压</li>
<li>身份验证:防止未经授权的节点加入集群</li>
<li>加密：消息加密</li>
</ul>
<h2 id="JGroups-主要API-org-jgroups-JChannel"><a href="#JGroups-主要API-org-jgroups-JChannel" class="headerlink" title="JGroups 主要API org.jgroups.JChannel"></a>JGroups 主要API org.jgroups.JChannel</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class JChannel extends Channel &#123;</span><br><span class="line">public JChannel(String properties) throws ChannelException;</span><br><span class="line">public void setReceiver(Receiver r);</span><br><span class="line">public void connect(String cluster_name) throws ChannelException;</span><br><span class="line">public void send(Message msg) throws ChannelException;</span><br><span class="line">public View getView();</span><br><span class="line">public Address getLocalAddress();</span><br><span class="line">public void disconnect();</span><br><span class="line">public void close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建一个channal 并调用 connect() 方法来加入一个集群<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Channel ch=new JChannel(“/home/bela/udp.xml”);</span><br><span class="line">ch.setReceiver(new ReceiverAdapter() &#123;</span><br><span class="line">public void receive(Message msg) &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">ch.connect(“demo-cluster”);</span><br></pre></td></tr></table></figure></p>
<p>这将创建一个在/home/bela/udp.xml 中定义的 channal，如果应用需要不同的设置可以在udp.xml中修改，并作为构造函数的参数传入。</p>
<p>然后我们设置一个 Receiver ，它将会在消息接收以后被回调，最后我们加入一个集群，所有的channal都是类似的配置，并加入相同的集群。</p>
<p>当一个节点加入一个集群以后它就可以接收来自集群成员发送的消息。<br><img src="/2019/07/14/JGroups入门/timg.jpg" alt=""><br>Receiver 接口有两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void receive(Message msg);</span><br><span class="line">void viewAccepted(View new_view);</span><br></pre></td></tr></table></figure></p>
<p>receive() 方法将在消息到达的时候被回调。它有一个 org.jgroups.Message 类型的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Message implements Streamable &#123;</span><br><span class="line">	protected Address dest_addr=null;</span><br><span class="line">	protected Address src_addr=null;</span><br><span class="line">	private byte[] buf=null;</span><br><span class="line"></span><br><span class="line">	public byte[] getBuffer();</span><br><span class="line">	public void setBuffer(byte[] b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>message 中定义了一个目的地地址和一个发送方地址，一个Address 是在集群中标明一个节点的不透明类型。如果目的地地址是一个null则意味着这条消息将被发送到集群中所有的节点中去，反之则将发送给集群中唯一的一个节点。</p>
<p>当接收到消息时，应用程序可以调用getBuffer() 将消息检索到字节缓冲区，然后将其反序列化为对应用程序有意义的数据。</p>
<p>viewAccepted() 方法将在某个节点加入集群或者离开集群的时候被回调。它有一个唯一的参数 View ，它本质上是一个地址列表，所有集群节点都以完全相同的顺序接收视图，因此当我们有一个集群a、B、C时，节点有以下视图:</p>
<ul>
<li>A: {A,B,C}</li>
<li>B: {A,B,C}</li>
<li>C: {A,B,C}</li>
</ul>
<p>如果此时集群中有一个新的节点D加入，那么此时集群列表应该是 {A,B,C,D}。如果 B 节点奔溃那么此时集群中所有的节点将收到 {A,C,D} 视图，正如我们所看到的，视图中的节点是根据连接时间排序的。最老的节点总是第一个。<br>现在我们来讨论一下JChannel的其余方法。<br>send()方法接收消息并将其发送给所有集群节点，如果消息的目的地为null，或者如果目的地是非null，则将其发送给单个节点。应用程序需要将它们的数据编组到一个字节缓冲区，并通过message.setbuffer()将其放入消息中。<br>要得到当前视图，我们可以使用channel.getview()，并获取一个节点的本地地址，我们调用channel.getlocaladdress()。<br>调用 disconnect() 方法离开一个集群。<br>close() 用于销毁一个channal，通道一旦被关闭则无法被再次打开。调用disconnect() 方法将会在所有节点中创建一个视图，viewAccepted() 方法将会在所有节点中执行。</p>
<h2 id="分布式任务系统"><a href="#分布式任务系统" class="headerlink" title="分布式任务系统"></a>分布式任务系统</h2><p>我们的想法非常简单，我们有一个由若干节点组成的集群，并且集群中的每个节点可以提交任务集群中的任何一个节点上执行，所以每个节点是平等的。简单的理解就是一个节点既可以提交任务也可以执行任务。在一个真实的系统中，客户端可以通过TCP 或者RMI 连接到集群中任何一个节点上，并提交一个任务，包括它自己。<br>当提交一个任务以后我们会产生一个随机的整数用来映射到集群中的某个节点上去，我们称其为秩。这个秩其实就是节点在 view中的位置，因为view中的位置在所有节点中都是相同的。秩是节点的唯一标识。<br>任务是通过多播在集群中执行的，每个节点都将任务添加到由任务及其提交者(JGroups)地址组成的散列map中。<br>每个节点比较任务的秩与自己的秩是否相同，如果秩与自己的秩匹配则执行任务 并将结果返回给提交者，反之则什么也不做。<br>当任务提交者接受到一个执行结果，它将通过多播的方式告诉集群中的所有节点，移除这个任务在map中。<br>如果此时接受任务的节点崩溃，则我们可以通过map找到哪些任务被提交给了这个节点，这个时候我们需要重新生成一个任务秩，并重新提交这个任务给其他节点。<br>如果master节点在提交了任务以后奔溃，同时没有收到任务执行结果，则此时所有的slave移除所有由此master提交的任务，因为任务执行结果对这个master来讲是毫无意义的。</p>
<p>下图是所有任务在集群中的分发示意图<br><img src="/2019/07/14/JGroups入门/11243.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>详情在<a href="https://github.com/NormanDai/hydra" target="_blank" rel="noopener">https://github.com/NormanDai/hydra</a></p>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://yoursite.com/2019/07/14/JGroups入门/" data-id="cjzwlsaze00aw7kfv7eo4shv2" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>关注我 :</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1466132938&site=qq&menu=yes" target="_blank" rel="noopener">
                          <i class="icon fa fa-qq"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2019/07/15/浏览器缓存机制/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">下一篇</strong>
        <p class="article-nav-title">
        
            浏览器缓存机制
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2019/07/14/jedisPool与RedisTemplate/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">上一篇</strong>
        <p class="article-nav-title">jedisPool与RedisTemplate</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/08/29/10个基于JavaScript的机器学习实例/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/08/29/10个基于JavaScript的机器学习实例/1.png)" alt="10个基于JavaScript的机器学习实例" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/08/29/10个基于JavaScript的机器学习实例/" class="title">10个基于JavaScript的机器学习实例</a></p>
                            <p class="item-date"><time datetime="2019-08-29T10:20:15.000Z" itemprop="datePublished">2019-08-29</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/08/29/四幅思维导图学会Python爬虫/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/08/29/四幅思维导图学会Python爬虫/1.png)" alt="四幅思维导图学会Python爬虫" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/08/29/四幅思维导图学会Python爬虫/" class="title">四幅思维导图学会Python爬虫</a></p>
                            <p class="item-date"><time datetime="2019-08-29T09:43:14.000Z" itemprop="datePublished">2019-08-29</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/08/29/比Thread-sleep优雅的线程睡眠/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/08/29/比Thread-sleep优雅的线程睡眠/90829171904.png)" alt="比Thread.sleep优雅的线程睡眠" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/08/29/比Thread-sleep优雅的线程睡眠/" class="title">比Thread.sleep优雅的线程睡眠</a></p>
                            <p class="item-date"><time datetime="2019-08-29T09:16:39.000Z" itemprop="datePublished">2019-08-29</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/08/29/提到Serverless你需要知道什么/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/08/29/提到Serverless你需要知道什么/9fc54f7427.webp)" alt="提到Serverless你需要知道什么" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/08/29/提到Serverless你需要知道什么/" class="title">提到Serverless你需要知道什么</a></p>
                            <p class="item-date"><time datetime="2019-08-29T07:48:37.000Z" itemprop="datePublished">2019-08-29</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/08/28/17幅思维导图-Python核心知识体系/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/08/28/17幅思维导图-Python核心知识体系/rules.png)" alt="17幅思维导图:Python核心知识体系" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/08/28/17幅思维导图-Python核心知识体系/" class="title">17幅思维导图:Python核心知识体系</a></p>
                            <p class="item-date"><time datetime="2019-08-28T10:00:09.000Z" itemprop="datePublished">2019-08-28</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/">JAVA</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/">JSP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">16</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javaweb/">Javaweb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jquery/">Jquery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/">PHP</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Springboot/">Springboot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajax/">ajax</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript库/">javascript库</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/">maven</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/orcal/">orcal</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/struts2/">struts2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/冷知识/">冷知识</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发工具/">开发工具</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源项目/">开源项目</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/心语/">心语</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能测试/">性能测试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器/">浏览器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存机制/">缓存机制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/舆论/">舆论</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机/">计算机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目用到/">项目用到</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/JAVA/" style="font-size: 10.83px;">JAVA</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 12.5px;">JVM</a> <a href="/tags/Java/" style="font-size: 16.67px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 19.17px;">JavaScript</a> <a href="/tags/Javaweb/" style="font-size: 10px;">Javaweb</a> <a href="/tags/Jquery/" style="font-size: 10px;">Jquery</a> <a href="/tags/Linux/" style="font-size: 10.83px;">Linux</a> <a href="/tags/PHP/" style="font-size: 15.83px;">PHP</a> <a href="/tags/Python/" style="font-size: 10.83px;">Python</a> <a href="/tags/Redis/" style="font-size: 10px;">Redis</a> <a href="/tags/Springboot/" style="font-size: 10px;">Springboot</a> <a href="/tags/XML/" style="font-size: 10.83px;">XML</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/git/" style="font-size: 10.83px;">git</a> <a href="/tags/html/" style="font-size: 17.5px;">html</a> <a href="/tags/java/" style="font-size: 18.33px;">java</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/javascript库/" style="font-size: 20px;">javascript库</a> <a href="/tags/maven/" style="font-size: 15px;">maven</a> <a href="/tags/node/" style="font-size: 10.83px;">node</a> <a href="/tags/orcal/" style="font-size: 13.33px;">orcal</a> <a href="/tags/python/" style="font-size: 14.17px;">python</a> <a href="/tags/struts2/" style="font-size: 10px;">struts2</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/冷知识/" style="font-size: 12.5px;">冷知识</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/开发工具/" style="font-size: 14.17px;">开发工具</a> <a href="/tags/开源项目/" style="font-size: 10px;">开源项目</a> <a href="/tags/心语/" style="font-size: 11.67px;">心语</a> <a href="/tags/性能测试/" style="font-size: 10px;">性能测试</a> <a href="/tags/技术/" style="font-size: 12.5px;">技术</a> <a href="/tags/数据结构与算法/" style="font-size: 15px;">数据结构与算法</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/浏览器/" style="font-size: 10px;">浏览器</a> <a href="/tags/缓存机制/" style="font-size: 10px;">缓存机制</a> <a href="/tags/舆论/" style="font-size: 10px;">舆论</a> <a href="/tags/计算机/" style="font-size: 10px;">计算机</a> <a href="/tags/项目用到/" style="font-size: 10px;">项目用到</a>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2019 陈义</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
            <div>
                <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                本站总访问量 <span id="busuanzi_value_site_pv"></span> 次&nbsp&nbsp&nbsp
                本站访客数<span id="busuanzi_value_site_uv"></span>人次
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

        
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'http://yoursite.com/2019/07/14/JGroups入门/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
