<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">

    

    
    <title>Java两种动态代理JDK动态代理和CGLIB动态代理 | 陈义的个人博客</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="java">
    
    <meta name="description" content="前言参考：https://www.cnblogs.com/xrq730/p/4919025.html#undefined为什么要实现AOPAOP全名Aspect-Oriented Programming，中文直译为面向切面(方面)编程。何为切面，就比如说我们系统中的权限管理，日志，事务等我们都可以将其看成一个个切面。在传统的OOP编程中，一些与业务无关的，日志，安全，事务，性能等代码与业务代码牢牢">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java两种动态代理JDK动态代理和CGLIB动态代理">
<meta property="og:url" content="http://yoursite.com/2019/07/19/Java两种动态代理JDK动态代理和CGLIB动态代理/index.html">
<meta property="og:site_name" content="陈义的个人博客">
<meta property="og:description" content="前言参考：https://www.cnblogs.com/xrq730/p/4919025.html#undefined为什么要实现AOPAOP全名Aspect-Oriented Programming，中文直译为面向切面(方面)编程。何为切面，就比如说我们系统中的权限管理，日志，事务等我们都可以将其看成一个个切面。在传统的OOP编程中，一些与业务无关的，日志，安全，事务，性能等代码与业务代码牢牢">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/07/19/Java两种动态代理JDK动态代理和CGLIB动态代理/43117298.png">
<meta property="og:updated_time" content="2019-08-07T08:51:25.902Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java两种动态代理JDK动态代理和CGLIB动态代理">
<meta name="twitter:description" content="前言参考：https://www.cnblogs.com/xrq730/p/4919025.html#undefined为什么要实现AOPAOP全名Aspect-Oriented Programming，中文直译为面向切面(方面)编程。何为切面，就比如说我们系统中的权限管理，日志，事务等我们都可以将其看成一个个切面。在传统的OOP编程中，一些与业务无关的，日志，安全，事务，性能等代码与业务代码牢牢">
<meta name="twitter:image" content="http://yoursite.com/2019/07/19/Java两种动态代理JDK动态代理和CGLIB动态代理/43117298.png">
    

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/3.3.1/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    


</head>
</html>
<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">学而不思则罔，思而不学则殆</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item">
                                    <a class="main-nav-list-link" href="/">主页</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/推荐好文/">推荐好文</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/遥感/">遥感</a></li></ul>
                                    
                                <li class="main-nav-list-item">
                                    <a class="main-nav-list-link" href="/about/index.html">关于</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form" method="GET" action="https://www.baidu.com/s?">
    <input name="wd" type="text" class="search-form-input" placeholder="搜索">
</form>
<script>
(function ($) {
    $('.search-form').on('submit', function (e) {
        var keyword = $('.search-form-input[name="wd"]').val();
        window.location = 'https://www.baidu.com/s?wd=site:yoursite.com ' + keyword;
        return false;
    });
})(jQuery);
</script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    未分类
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-Java两种动态代理JDK动态代理和CGLIB动态代理" class="article article-single article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        Java两种动态代理JDK动态代理和CGLIB动态代理
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2019/07/19/Java两种动态代理JDK动态代理和CGLIB动态代理/" class="article-date">
            <time datetime="2019-07-19T11:15:32.000Z" itemprop="datePublished">2019-07-19</time>
        </a>
    </div>

		

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/java/">java</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>参考：<a href="https://www.cnblogs.com/xrq730/p/4919025.html#undefined" target="_blank" rel="noopener">https://www.cnblogs.com/xrq730/p/4919025.html#undefined</a><br><strong>为什么要实现AOP</strong><br>AOP全名Aspect-Oriented Programming，中文直译为面向切面(方面)编程。何为切面，就比如说我们系统中的权限管理，日志，事务等我们都可以将其看成一个个切面。<br>在传统的OOP编程中，一些与业务无关的，日志，安全，事务，性能等代码与业务代码牢牢交织在一起。如下图所示：有订单管理，用户管理，订单管理等业务模块。每个模块都实现了自己的日志，安全，事务，性能统计。<br><img src="/2019/07/19/Java两种动态代理JDK动态代理和CGLIB动态代理/43117298.png" alt=""></p>
<p>如果我们修改了业务代码就需要修改相应的日志代码。<br>使用了AOP之后我们可以将日志，安全，事务，性能统计等代码作为一个切面。切入到业务代码中。<br><img src="/2019/07/19/Java两种动态代理JDK动态代理和CGLIB动态代理/455143.png" alt=""><br><strong>AOP的基本概念</strong></p>
<ul>
<li>Joint Point (连接点)<br>被拦截到的点，在Spring AOP中通常是方法类型（a point during the execution of a program, such as the execution of a method or the handling of an exception）</li>
<li>Pointcut（切入点）<br>对连接点进行拦截的定义，在程序中主要体现为书写的切点表达式<br>（a predicate that matches join points）<br>例如：execution(<em> org.litespring.service.v5.</em>.placeOrder(..))</li>
<li>Advice（通知）<br>AOP在特定的切入点上执行的增强处理，有before,after,afterReturning,afterThrowing,around等通知<br>（action taken at a particular join point<br>Many AOP frameworks, including Spring, model an advice as an interceptor, maintaining a chain of interceptors around the join point.<br>）</li>
<li>Before advice（前置通知）<br>在连接点之前的通知（Advice that executes before a join point）</li>
<li>After returning advice（后置通知）<br>在连接点之后的通知，没有抛出异常（Advice to be executed after a join point completes normally: for example, if a method returns without throwing an exception）</li>
<li>After throwing advice（异常通知）<br>如果方法抛出异常的通知（Advice to be executed if a method exits by throwing an exception）</li>
<li>After (finally) advice （finally 通知）<br>不过连接点的方法是否正常或者抛出异常，都会执行的通知<br>（Advice to be executed regardless of the means by which a join point exits (normal or exceptional return) ）</li>
<li>Around advice （环绕通知）<br>在连接点之前或者之后都可以执行的通知。可以全局的在方法前后自定义行为。<br>(Advice that surrounds a join point such as a method invocation， Around advice can perform custom behavior before and after the method invocation)<br><strong>怎么实现AOP</strong><br>AOP是在运行期通过动态代理生成代理类的方式对方法进行增强的。</li>
<li>CGLib动态代理<br>CGLib (Code Generation Library)是一个开源项目！是一个强大的,高性能,高质量的Code生成类库。<br>它能够在执行期扩展Java类与实现Java接口。Hibernate用它来实现PO字节码的动态生成。<br>CGLIB是一个强大的高性能的代码生成包。它广泛的被许多AOP的框架使用，例如Spring AOP为他们提供方法的interception（拦截）。<br>CGLib比 Java 的 java.lang.reflect.Proxy 类更强的在于它不仅能够接管接口类的方法。还能够接管普通类的方法。<br>CGLIB包的底层是通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。<br>CGLib就是封装了ASM，简化了ASM的操作，实现了在执行期动态生成新的class。ASM是直接生成class类的方式。不会有性能问题（相对来说）<br>除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成java的字节码。当然不鼓励直接使用ASM，因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。</li>
</ul>
<p>在运行时动态生成一个类，继承待增强的类，在placeOrder中添加需要增强的代码，CGLib动态代理实际上是应用于类的代理。如图所示：<br><img src="/2019/07/19/Java两种动态代理JDK动态代理和CGLIB动态代理/0400582.png" alt=""></p>
<ul>
<li>Java 动态代理<br>Java 动态代理是应用于接口的代理。<br><img src="/2019/07/19/Java两种动态代理JDK动态代理和CGLIB动态代理/6125389.png" alt=""></li>
</ul>
<h2 id="两种动态代理"><a href="#两种动态代理" class="headerlink" title="两种动态代理"></a>两种动态代理</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><pre><code>代理模式是23种设计模式的一种，他是指一个对象A通过持有另一个对象B，可以具有B同样的行为的模式。为了对外开放协议，B往往实现了一个接口，A也会去实现接口。但是B是“真正”实现类，A则比较“虚”，他借用了B的方法去实现接口的方法。A虽然是“伪军”，但它可以增强B，在调用B的方法前后都做些其他的事情。Spring AOP就是使用了动态代理完成了代码的动态“织入”。
使用代理好处还不止这些，一个工程如果依赖另一个工程给的接口，但是另一个工程的接口不稳定，经常变更协议，就可以使用一个代理，接口变更时，只需要修改代理，不需要一一修改业务代码。从这个意义上说，所有调外界的接口，我们都可以这么做，不让外界的代码对我们的代码有侵入，这叫防御式编程。代理其他的应用可能还有很多。
上述例子中，类A写死持有B，就是B的静态代理。如果A代理的对象是不确定的，就是动态代理。动态代理目前有两种常见的实现，jdk动态代理和cglib动态代理。
</code></pre><h3 id="实现原理-JDK的动态代理-VS-CGLib"><a href="#实现原理-JDK的动态代理-VS-CGLib" class="headerlink" title="实现原理:JDK的动态代理 (VS) CGLib"></a>实现原理:JDK的动态代理 (VS) CGLib</h3><p>JDK的动态代理——依据java的反射机制动态生成<br>         利用反射。获取托付类的类载入器。托付类的全部接口，实例化代理类。<br>通过反射类Proxy以及InvationHandler回调接口实现的。可是动态代理类仅仅能对该类所实现的接口中的方法进行代理。<br>具有一定的局限性，而且反射的效率也不是非常高。<br>          Proxy 毕竟是通过反射实现的，必须在效率上付出代价：有实验数据表明，调用反射比一般的函数开销至少要大 10 倍。<br>从程序实现上能够看出，对 proxyclass 的全部方法调用都要通过使用反射的 invoke 方法。<br>因此。对于性能关键的应用。使用 proxy class是须要精心考虑的。以避免反射成为整个应用的瓶颈。</p>
<p>CGLib ——利用ASM生成字节码原理。利用增强类，创建代理类<br>       CGLib底层採用ASM字节码生成框架。使用字节码技术生成代理类。比反射效率要高。<br>可是须要主要注意的，CGLib不能对声明为final的方法进行代理。<br>由于CGLib原理是动态的生成被代理类的子类。<br>        ASM可以通过改造既有类，直接生成须要的代码。<br>增强的代码是硬编码在新生成的类文件内部的，没有反射带来性能上的付出。它是一个普通的 Java 类而不是 proxy类，甚至可以在应用程序的类框架中拥有自己的位置，派生自己的子类。<br>         在调用目标方法的时候，CGLib会回调MethodInterceptor接口方法拦截。来实现你自己的代理逻辑，类似于JDK中的InvocationHandler接口</p>
<h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p><strong>1.通过 Proxy类进行代理</strong><br>jdk动态代理是jre提供给我们的类库，可以直接使用，不依赖第三方。先看下jdk动态代理的使用代码，再理解原理。</p>
<p>首先有个“明星”接口类，有唱、跳两个功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package proxy;</span><br><span class="line"> </span><br><span class="line">public interface Star</span><br><span class="line">&#123;</span><br><span class="line">    String sing(String name);</span><br><span class="line">    </span><br><span class="line">    String dance(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再有个明星实现类“刘德华”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package proxy;</span><br><span class="line"> </span><br><span class="line">public class LiuDeHua implements Star</span><br><span class="line">&#123;   </span><br><span class="line">    @Override</span><br><span class="line">    public String sing(String name)</span><br><span class="line">    &#123;</span><br><span class="line">         System.out.println(&quot;给我一杯忘情水&quot;);</span><br><span class="line"> </span><br><span class="line">        return &quot;唱完&quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public String dance(String name)</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;开心的马骝&quot;);</span><br><span class="line"> </span><br><span class="line">        return &quot;跳完&quot; ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>明星演出前需要有人收钱，由于要准备演出，自己不做这个工作，一般交给一个经纪人。便于理解，它的名字以Proxy结尾，但他不是代理类，原因是它没有实现我们的明星接口，无法对外服务，它仅仅是一个wrapper。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package proxy;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"> </span><br><span class="line">public class StarProxy implements InvocationHandler</span><br><span class="line">&#123;</span><br><span class="line">    // 目标类，也就是被代理对象</span><br><span class="line">    private Object target;</span><br><span class="line">    </span><br><span class="line">    public void setTarget(Object target)</span><br><span class="line">    &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable</span><br><span class="line">    &#123;</span><br><span class="line">		//method 是目标类的方法     args 是目标类的入参数   proxy是目标类实例  发生异常则抛给Throwable</span><br><span class="line">        // 这里可以做增强</span><br><span class="line">        System.out.println(&quot;收钱&quot;);</span><br><span class="line">        </span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        </span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 生成代理类</span><br><span class="line">    public Object CreatProxyedObj()</span><br><span class="line">    &#123;</span><br><span class="line">        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);</span><br><span class="line">    &#125;  </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述例子中，方法CreatProxyedObj返回的对象才是我们的代理类，它需要三个参数，前两个参数的意思是在同一个classloader下通过接口创建出一个对象，该对象需要一个属性，也就是第三个参数，它是一个InvocationHandler。需要注意的是这个CreatProxyedObj方法不一定非得在我们的StarProxy类中，往往放在一个工厂类中。上述代理的代码使用过程一般如下：</p>
<p>1、new一个目标对象</p>
<p>2、new一个InvocationHandler，将目标对象set进去</p>
<p>3、通过CreatProxyedObj创建代理对象，强转为目标对象的接口类型即可使用，实际上生成的代理对象实现了目标接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Star ldh = new LiuDeHua();</span><br><span class="line"> </span><br><span class="line">StarProxy proxy = new StarProxy();</span><br><span class="line"> </span><br><span class="line">proxy.setTarget(ldh); </span><br><span class="line">  </span><br><span class="line">Object obj = proxy.CreatProxyedObj();</span><br><span class="line"></span><br><span class="line">Star star = (Star)obj;</span><br></pre></td></tr></table></figure></p>
<p>Proxy（jdk类库提供）根据B的接口生成一个实现类，我们成为C，它就是动态代理类（该类型是 $Proxy+数字 的“新的类型”）。生成过程是：由于拿到了接口，便可以获知接口的所有信息（主要是方法的定义），也就能声明一个新的类型去实现该接口的所有方法，这些方法显然都是“虚”的，它调用另一个对象的方法。当然这个被调用的对象不能是对象B，如果是对象B，我们就没法增强了，等于饶了一圈又回来了。</p>
<p>所以它调用的是B的包装类，这个包装类需要我们来实现，但是jdk给出了约束，它必须实现InvocationHandler，上述例子中就是StarProxy， 这个接口里面有个方法，它是所有Target的所有方法的调用入口（invoke），调用之前我们可以加自己的代码增强。</p>
<p>看下我们的实现，我们在InvocationHandler里调用了对象B（target）的方法，调用之前增强了B的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable</span><br><span class="line">&#123;</span><br><span class="line">    // 这里增强</span><br><span class="line">    System.out.println(&quot;收钱&quot;);</span><br><span class="line">    </span><br><span class="line">    Object result = method.invoke(target, args);</span><br><span class="line">    </span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以可以这么认为C代理了InvocationHandler，InvocationHandler代理了我们的类B，两级代理。</p>
<p><code>整个JDK动态代理的秘密也就这些，简单一句话，动态代理就是要生成一个包装类对象，由于代理的对象是动态的，所以叫动态代理。由于我们需要增强，这个增强是需要留给开发人员开发代码的，因此代理类不能直接包含被代理对象，而是一个InvocationHandler，该InvocationHandler包含被代理对象，并负责分发请求给被代理对象，分发前后均可以做增强。从原理可以看出，JDK动态代理是“对象”的代理。</code></p>
<p>下面看下动态代理类到底如何调用的InvocationHandler的，为什么InvocationHandler的一个invoke方法能为分发target的所有方法。C中的部分代码示例如下，通过反编译生成后的代码查看，摘自<a href="https://blog.csdn.net/jiankunking/article/details/52143504" target="_blank" rel="noopener">链接地址</a> 。Proxy创造的C是自己（Proxy）的子类，且实现了B的接口，一般都是这么修饰的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class XXX extends Proxy implements XXX</span><br></pre></td></tr></table></figure></p>
<p>一个方法代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final String SayHello(String paramString)</span><br><span class="line">&#123;</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">    return (String)this.h.invoke(this, m4, new Object[] &#123; paramString &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Error|RuntimeException localError)</span><br><span class="line">  &#123;</span><br><span class="line">    throw localError;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable localThrowable)</span><br><span class="line">  &#123;</span><br><span class="line">    throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，C中的方法全部通过调用h实现，其中h就是InvocationHandler，是我们在生成C时传递的第三个参数。这里还有个关键就是SayHello方法（业务方法）跟调用invoke方法时传递的参数m4一定要是一一对应的，但是这些对我们来说都是透明的，由Proxy在newProxyInstance时保证的。留心看到C在invoke时把自己this传递了过去，InvocationHandler的invoke的第一个方法也就是我们的动态代理实例类，业务上有需要就可以使用它。（所以千万不要在invoke方法里把请求分发给第一个参数，否则很明显就死循环了）</p>
<p>C类中有B中所有方法的成员变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static Method m1;</span><br><span class="line">private static Method m3;</span><br><span class="line">private static Method m4;</span><br><span class="line">private static Method m2;</span><br><span class="line">private static Method m0;</span><br></pre></td></tr></table></figure></p>
<p>这些变量在static静态代码块初始化，这些变量是在调用invocationhander时必要的入参，也让我们依稀看到Proxy在生成C时留下的痕迹。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">static</span><br><span class="line">  &#123;</span><br><span class="line">    try</span><br><span class="line">    &#123;</span><br><span class="line">      m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, new Class[] &#123; Class.forName(&quot;java.lang.Object&quot;) &#125;);</span><br><span class="line">      m3 = Class.forName(&quot;jiankunking.Subject&quot;).getMethod(&quot;SayGoodBye&quot;, new Class[0]);</span><br><span class="line">      m4 = Class.forName(&quot;jiankunking.Subject&quot;).getMethod(&quot;SayHello&quot;, new Class[] &#123; Class.forName(&quot;java.lang.String&quot;) &#125;);</span><br><span class="line">      m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);</span><br><span class="line">      m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);</span><br><span class="line">      return;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (NoSuchMethodException localNoSuchMethodException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoSuchMethodError(localNoSuchMethodException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    catch (ClassNotFoundException localClassNotFoundException)</span><br><span class="line">    &#123;</span><br><span class="line">      throw new NoClassDefFoundError(localClassNotFoundException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>从以上分析来看，要想彻底理解一个东西，再多的理论不如看源码，底层的原理非常重要。<br>jdk动态代理类图如下<br><img src="/2019/07/19/Java两种动态代理JDK动态代理和CGLIB动态代理/46535.jpg" alt=""></p>
<p><strong>2.通过spring的配置文件进行代理</strong></p>
<p>　　这个方法进行代理所需的类和上面的 Star接口 和 它的实现类LiuDeHua 还有StarProxy类</p>
<p>　　不同之处在于不是使用 ProxtyFactory来进行代理目标对象，而是通过Schema 的xml文件进行配置代理。</p>
<p>beans.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;StarProxy &quot; class=&quot;proxy.dance&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;target&quot; class=&quot;proxy.LiuDeHua&quot;/&gt;</span><br><span class="line">    &lt;bean id=&quot;LiuDeHua&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;</span><br><span class="line">        p:proxyInterfaces=&quot;proxy.Star&quot;</span><br><span class="line">        p:interceptorNames=&quot;StarProxy &quot;</span><br><span class="line">        p:target-ref=&quot;target&quot;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>target:代理的目标对象 </p>
</li>
<li><p>proxyInterfaces:代理所需要实现的接口，可以多个接口。该属性还有一个别名是Interfaces</p>
</li>
<li><p>interceptorNames:需要植入目标对象的bean列表。采用bean的名称指定。这些bean必须实现类 org.aopalliance.intercept.MethodInterceptor</p>
<pre><code>　　或 org.springframework.aop.Advisor的bean ,配置中的顺序对应调用的顺序。
</code></pre></li>
<li><p>proxyTargetClass:是否对类进行代理(而不是进行对接口进行代理),设置为true时，使用CGLib代理，且proxyInterfaces属性被ProxyFactoryBean忽略。</p>
</li>
</ul>
<p>UnitTest.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class UnitTest &#123; </span><br><span class="line">    @Test //测试在spring 通过ProxyFactoryBean 配置代理</span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        ApplicationContext a = new ClassPathXmlApplicationContext(&quot;proxy/beans.xml&quot;);</span><br><span class="line">        Star w = (Star)a.getBean(&quot;LiuDeHua&quot;);</span><br><span class="line">        w.sing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h3><p>我们了解到，“代理”的目的是构造一个和被代理的对象有同样行为的对象，一个对象的行为是在类中定义的，对象只是类的实例。所以构造代理，不一定非得通过持有、包装对象这一种方式。<br>参考：<a href="https://blog.csdn.net/yhl_jxy/article/details/80633194" target="_blank" rel="noopener">https://blog.csdn.net/yhl_jxy/article/details/80633194</a><br>通过“继承”可以继承父类所有的公开方法，然后可以重写这些方法，在重写时对这些方法增强，这就是cglib的思想。根据里氏代换原则（LSP），父类需要出现的地方，子类可以出现，所以cglib实现的代理也是可以被正常使用的。</p>
<p>先看下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package proxy;</span><br><span class="line"> </span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line"> </span><br><span class="line">import net.sf.cglib.proxy.Enhancer;</span><br><span class="line">import net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line">import net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"> </span><br><span class="line">public class CglibProxy implements MethodInterceptor</span><br><span class="line">&#123;</span><br><span class="line">    // 根据一个类型产生代理类，此方法不要求一定放在MethodInterceptor中</span><br><span class="line">    public Object CreatProxyedObj(Class&lt;?&gt; clazz)</span><br><span class="line">    &#123;</span><br><span class="line">        Enhancer enhancer = new Enhancer();</span><br><span class="line">        </span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        </span><br><span class="line">        enhancer.setCallback(this);</span><br><span class="line">        </span><br><span class="line">        return enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Object arg0, Method arg1, Object[] arg2, MethodProxy arg3) throws Throwable</span><br><span class="line">    &#123;</span><br><span class="line">        // 这里增强</span><br><span class="line">        System.out.println(&quot;收钱&quot;);</span><br><span class="line">        </span><br><span class="line">        return arg3.invokeSuper(arg0, arg2);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从代码可以看出，它和jdk动态代理有所不同，对外表现上看CreatProxyedObj，它只需要一个类型clazz就可以产生一个代理对象， 所以说是“类的代理”，且创造的对象通过打印类型发现也是一个新的类型。不同于jdk动态代理，jdk动态代理要求对象必须实现接口（三个参数的第二个参数），cglib对此没有要求。</p>
<p>cglib的原理是这样，它生成一个继承B的类型C（代理类），这个代理类持有一个MethodInterceptor，我们setCallback时传入的。 C重写所有B中的方法（方法名一致），然后在C中，构建名叫“CGLIB”+“$父类方法名$”的方法（下面叫cglib方法，所有非private的方法都会被构建），方法体里只有一句话super.方法名()，可以简单的认为保持了对父类方法的一个引用，方便调用。</p>
<p>这样的话，C中就有了重写方法、cglib方法、父类方法（不可见），还有一个统一的拦截方法（增强方法intercept）。其中重写方法和cglib方法肯定是有映射关系的。</p>
<p>C的重写方法是外界调用的入口（LSP原则），它调用MethodInterceptor的intercept方法，调用时会传递四个参数，第一个参数传递的是this，代表代理类本身，第二个参数标示拦截的方法，第三个参数是入参，第四个参数是cglib方法，intercept方法完成增强后，我们调用cglib方法间接调用父类方法完成整个方法链的调用。</p>
<p><code>这里有个疑问就是intercept的四个参数，为什么我们使用的是arg3而不是arg1?</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object intercept(Object arg0, Method arg1, Object[] arg2, MethodProxy arg3) throws Throwable</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(&quot;收钱&quot;);</span><br><span class="line">    </span><br><span class="line">    return arg3.invokeSuper(arg0, arg2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 因为如果我们通过反射 arg1.invoke(arg0, …)这种方式是无法调用到父类的方法的，子类有方法重写，隐藏了父类的方法，父类的方法已经不可见，如果硬调arg1.invoke(arg0, …)很明显会死循环。</p>
<p>所以调用的是cglib开头的方法，但是，我们使用arg3也不是简单的invoke，而是用的invokeSuper方法，这是因为cglib采用了fastclass机制，不仅巧妙的避开了调不到父类方法的问题，还加速了方法的调用。</p>
<p>fastclass基本原理是，给每个方法编号，通过编号找到方法执行避免了通过反射调用。</p>
<p><code>对比JDK动态代理，cglib依然需要一个第三者分发请求，只不过jdk动态代理分发给了目标对象，cglib最终分发给了自己，通过给method编号完成调用。cglib是继承的极致发挥，本身还是很简单的，只是fastclass需要另行理解。</code></p>
<p>参考</p>
<p><a href="https://blog.csdn.net/jiankunking/article/details/52143504" target="_blank" rel="noopener">https://blog.csdn.net/jiankunking/article/details/52143504</a></p>
<p><a href="http://www.php.cn/java-article-407212.html" target="_blank" rel="noopener">http://www.php.cn/java-article-407212.html</a></p>
<p><a href="https://www.cnblogs.com/chinajava/p/5880887.html" target="_blank" rel="noopener">https://www.cnblogs.com/chinajava/p/5880887.html</a></p>
<p><a href="https://rejoy.iteye.com/blog/1627405" target="_blank" rel="noopener">https://rejoy.iteye.com/blog/1627405</a></p>
<p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)</span><br><span class="line"> &#123;</span><br><span class="line">     int times = 1000000;</span><br><span class="line">     </span><br><span class="line">     Star ldh = new LiuDeHua();</span><br><span class="line">     StarProxy proxy = new StarProxy();</span><br><span class="line">     proxy.setTarget(ldh);</span><br><span class="line">     </span><br><span class="line">     long time1 = System.currentTimeMillis();</span><br><span class="line">     Star star = (Star)proxy.CreatProxyedObj();</span><br><span class="line">     long time2 = System.currentTimeMillis();</span><br><span class="line">     System.out.println(&quot;jdk创建时间：&quot; + (time2 - time1));</span><br><span class="line">     </span><br><span class="line">     CglibProxy proxy2 = new CglibProxy();</span><br><span class="line">     long time5 = System.currentTimeMillis();</span><br><span class="line">     Star star2 = (Star)proxy2.CreatProxyedObj(LiuDeHua.class);</span><br><span class="line">     long time6 = System.currentTimeMillis();</span><br><span class="line">     System.out.println(&quot;cglib创建时间：&quot; + (time6 - time5));</span><br><span class="line">     </span><br><span class="line">     long time3 = System.currentTimeMillis();</span><br><span class="line">     for (int i = 1; i &lt;= times; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         star.sing(&quot;ss&quot;);</span><br><span class="line">         </span><br><span class="line">         star.dance(&quot;ss&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     long time4 = System.currentTimeMillis();</span><br><span class="line">     System.out.println(&quot;jdk执行时间&quot; + (time4 - time3));</span><br><span class="line">     </span><br><span class="line">     long time7 = System.currentTimeMillis();</span><br><span class="line">     for (int i = 1; i &lt;= times; i++)</span><br><span class="line">     &#123;</span><br><span class="line">         star2.sing(&quot;ss&quot;);</span><br><span class="line">         </span><br><span class="line">         star2.dance(&quot;ss&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     long time8 = System.currentTimeMillis();</span><br><span class="line">     </span><br><span class="line">     System.out.println(&quot;cglib执行时间&quot; + (time8 - time7));   </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>经测试，jdk创建对象的速度远大于cglib，这是由于cglib创建对象时需要操作字节码。cglib执行速度略大于jdk，所以比较适合单例模式。另外由于CGLIB的大部分类是直接对Java字节码进行操作，这样生成的类会在Java的永久堆中。如果动态代理操作过多，容易造成永久堆满，触发OutOfMemory异常。spring默认使用jdk动态代理，如果类没有接口，则使用cglib。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>CGLib的动态代理类。原理是继承，生成了被代理类的子类；而JDK的动态代理类。原理是反射，生成的代理类。实际不具备被代理类内部的方法，每一次调用都须要利用反射。调用被代理类的方法；再来看静态代理，代理类就是通过调用被代理类的方法进行执行的，而它自己本身并不详细被代理类的方法，JDK的动态代理的进步在于。利用反射，将类的载入延迟到程序执行中，解耦了代理类与被代理的关系。</p>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://yoursite.com/2019/07/19/Java两种动态代理JDK动态代理和CGLIB动态代理/" data-id="ck0ux1i9f009d2cfv4lik5mfw" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>关注我 :</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1466132938&site=qq&menu=yes" target="_blank" rel="noopener">
                          <i class="icon fa fa-qq"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2019/07/28/看源码我用IDEA/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">下一篇</strong>
        <p class="article-nav-title">
        
            看源码我用IDEA
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2019/07/15/Java开发最常犯的10个错误，打死都不要犯/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">上一篇</strong>
        <p class="article-nav-title">Java开发最常犯的10个错误，打死都不要犯!</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/09/22/基于redis的分布式锁的分析与实践/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/09/22/基于redis的分布式锁的分析与实践/ik41d52nnip.png)" alt="基于redis的分布式锁的分析与实践" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/09/22/基于redis的分布式锁的分析与实践/" class="title">基于redis的分布式锁的分析与实践</a></p>
                            <p class="item-date"><time datetime="2019-09-22T10:53:16.000Z" itemprop="datePublished">2019-09-22</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/09/21/如何访问redis中的海量数据/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/09/21/如何访问redis中的海量数据/=26&amp;gp=0.jpg)" alt="如何访问redis中的海量数据" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/09/21/如何访问redis中的海量数据/" class="title">如何访问redis中的海量数据</a></p>
                            <p class="item-date"><time datetime="2019-09-21T10:02:22.000Z" itemprop="datePublished">2019-09-21</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/09/21/8问Redis/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/09/21/8问Redis/1175005.jpg)" alt="8问Redis" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/09/21/8问Redis/" class="title">8问Redis</a></p>
                            <p class="item-date"><time datetime="2019-09-21T09:48:17.000Z" itemprop="datePublished">2019-09-21</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/09/21/深入了解Redis内存模型/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/09/21/深入了解Redis内存模型/1.png)" alt="深入了解Redis内存模型" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/09/21/深入了解Redis内存模型/" class="title">深入了解Redis内存模型</a></p>
                            <p class="item-date"><time datetime="2019-09-21T06:49:23.000Z" itemprop="datePublished">2019-09-21</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/09/18/Struts2框架基础概念总结/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/09/18/Struts2框架基础概念总结/1276201300.jpg)" alt="Struts2框架基础概念总结" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/09/18/Struts2框架基础概念总结/" class="title">Struts2框架基础概念总结</a></p>
                            <p class="item-date"><time datetime="2019-09-18T03:45:40.000Z" itemprop="datePublished">2019-09-18</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/">JAVA</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/">JSP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">16</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javaweb/">Javaweb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jquery/">Jquery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/">PHP</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Springboot/">Springboot</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Struts2/">Struts2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajax/">ajax</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript库/">javascript库</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/">maven</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/orcal/">orcal</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/struts2/">struts2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/冷知识/">冷知识</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发工具/">开发工具</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源项目/">开源项目</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/心语/">心语</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能测试/">性能测试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器/">浏览器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存机制/">缓存机制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/舆论/">舆论</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机/">计算机</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目用到/">项目用到</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/JAVA/" style="font-size: 10.91px;">JAVA</a> <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 12.73px;">JVM</a> <a href="/tags/Java/" style="font-size: 17.27px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 19.09px;">JavaScript</a> <a href="/tags/Javaweb/" style="font-size: 10px;">Javaweb</a> <a href="/tags/Jquery/" style="font-size: 10px;">Jquery</a> <a href="/tags/Linux/" style="font-size: 11.82px;">Linux</a> <a href="/tags/PHP/" style="font-size: 16.36px;">PHP</a> <a href="/tags/Python/" style="font-size: 10.91px;">Python</a> <a href="/tags/Redis/" style="font-size: 14.55px;">Redis</a> <a href="/tags/Springboot/" style="font-size: 10px;">Springboot</a> <a href="/tags/Struts2/" style="font-size: 10px;">Struts2</a> <a href="/tags/XML/" style="font-size: 10.91px;">XML</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/git/" style="font-size: 10.91px;">git</a> <a href="/tags/html/" style="font-size: 17.27px;">html</a> <a href="/tags/java/" style="font-size: 18.18px;">java</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/javascript库/" style="font-size: 20px;">javascript库</a> <a href="/tags/maven/" style="font-size: 15.45px;">maven</a> <a href="/tags/node/" style="font-size: 10.91px;">node</a> <a href="/tags/orcal/" style="font-size: 13.64px;">orcal</a> <a href="/tags/python/" style="font-size: 14.55px;">python</a> <a href="/tags/struts2/" style="font-size: 10px;">struts2</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/冷知识/" style="font-size: 12.73px;">冷知识</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/开发工具/" style="font-size: 14.55px;">开发工具</a> <a href="/tags/开源项目/" style="font-size: 10px;">开源项目</a> <a href="/tags/心语/" style="font-size: 11.82px;">心语</a> <a href="/tags/性能测试/" style="font-size: 10px;">性能测试</a> <a href="/tags/技术/" style="font-size: 12.73px;">技术</a> <a href="/tags/数据结构与算法/" style="font-size: 15.45px;">数据结构与算法</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/浏览器/" style="font-size: 10px;">浏览器</a> <a href="/tags/缓存机制/" style="font-size: 10px;">缓存机制</a> <a href="/tags/舆论/" style="font-size: 10px;">舆论</a> <a href="/tags/计算机/" style="font-size: 10px;">计算机</a> <a href="/tags/项目用到/" style="font-size: 10px;">项目用到</a>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2019 陈义</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
            <div>
                <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                本站总访问量 <span id="busuanzi_value_site_pv"></span> 次&nbsp&nbsp&nbsp
                本站访客数<span id="busuanzi_value_site_uv"></span>人次
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

        
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'http://yoursite.com/2019/07/19/Java两种动态代理JDK动态代理和CGLIB动态代理/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
