<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">

    

    
    <title>kotlin概览以及团队实践 | 陈义的个人博客</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="开发工具">
    
    <meta name="description" content="kotlin 优势kotlin 在 17 年 google io 大会上确定为亲儿子，android studio canary 3.0 版本开始，直接支持 kotlin 语言，不需要额外安装 as plugin。kotlin 的出现，给 android 开发者带来了极大的活力，现在的 android 工业开发，讲究的是语法糖，效率，性能，高质量，以及可拓展性，而 kotlin 的出现给 java">
<meta name="keywords" content="开发工具">
<meta property="og:type" content="article">
<meta property="og:title" content="kotlin概览以及团队实践">
<meta property="og:url" content="http://yoursite.com/2019/05/14/kotlin概览以及团队实践/index.html">
<meta property="og:site_name" content="陈义的个人博客">
<meta property="og:description" content="kotlin 优势kotlin 在 17 年 google io 大会上确定为亲儿子，android studio canary 3.0 版本开始，直接支持 kotlin 语言，不需要额外安装 as plugin。kotlin 的出现，给 android 开发者带来了极大的活力，现在的 android 工业开发，讲究的是语法糖，效率，性能，高质量，以及可拓展性，而 kotlin 的出现给 java">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2019/05/14/kotlin概览以及团队实践/e2dd4f41.webp">
<meta property="og:updated_time" content="2019-08-14T12:49:48.030Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="kotlin概览以及团队实践">
<meta name="twitter:description" content="kotlin 优势kotlin 在 17 年 google io 大会上确定为亲儿子，android studio canary 3.0 版本开始，直接支持 kotlin 语言，不需要额外安装 as plugin。kotlin 的出现，给 android 开发者带来了极大的活力，现在的 android 工业开发，讲究的是语法糖，效率，性能，高质量，以及可拓展性，而 kotlin 的出现给 java">
<meta name="twitter:image" content="http://yoursite.com/2019/05/14/kotlin概览以及团队实践/e2dd4f41.webp">
    

    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/3.3.1/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    


</head>
</html>
<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">学而不思则罔，思而不学则殆</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item">
                                    <a class="main-nav-list-link" href="/">主页</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/推荐好文/">推荐好文</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/遥感/">遥感</a></li></ul>
                                    
                                <li class="main-nav-list-item">
                                    <a class="main-nav-list-link" href="/about/index.html">关于</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form" method="GET" action="https://www.baidu.com/s?">
    <input name="wd" type="text" class="search-form-input" placeholder="搜索">
</form>
<script>
(function ($) {
    $('.search-form').on('submit', function (e) {
        var keyword = $('.search-form-input[name="wd"]').val();
        window.location = 'https://www.baidu.com/s?wd=site:yoursite.com ' + keyword;
        return false;
    });
})(jQuery);
</script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/推荐好文/">推荐好文</a>
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-kotlin概览以及团队实践" class="article article-single article-type-post" itemscope="" itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        kotlin概览以及团队实践
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2019/05/14/kotlin概览以及团队实践/" class="article-date">
            <time datetime="2019-05-14T12:18:04.000Z" itemprop="datePublished">2019-05-14</time>
        </a>
    </div>

		

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/开发工具/">开发工具</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h2 id="kotlin-优势"><a href="#kotlin-优势" class="headerlink" title="kotlin 优势"></a>kotlin 优势</h2><p>kotlin 在 17 年 google io 大会上确定为亲儿子，android studio canary 3.0 版本开始，直接支持 kotlin 语言，不需要额外安装 as plugin。<br>kotlin 的出现，给 android 开发者带来了极大的活力，现在的 android 工业开发，讲究的是语法糖，效率，性能，高质量，以及可拓展性，而 kotlin 的出现给 java 开发者带来了极大的福音。<br>kotlin 官网教程英文 <a href="https://kotlinlang.org/docs/reference/basic-types.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/basic-types.html</a><br>kotlin 官网教程中文 <a href="https://www.kotlincn.net/docs/reference/" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/</a><br><strong>阅读此文章大约半小时~</strong>如何阅读？浏览kotlin 优势和kotlin 坑这两大章节，然后去学习 kotlin 基础语法，根据第三章，kotlin 普及里的建议，可以在实际开发中，开干了。</p>
<h2 id="避免-npl以及非空判断更优雅"><a href="#避免-npl以及非空判断更优雅" class="headerlink" title="避免 npl以及非空判断更优雅"></a>避免 npl以及非空判断更优雅</h2><p>kotlin 默认是非空的，如果你需要声明一个可能为空的变量，那么如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private  var mName:String = &quot;kk&quot;</span><br><span class="line">private  var mSubName:String? = null</span><br></pre></td></tr></table></figure></p>
<p>这里的 mName 变量声明为，String 类型；mSubName 声明为 String?。前者不能为 null，后者可以为 null。<br>然后，你可能经常在 java 中写这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (mANRPA != null) &#123;</span><br><span class="line">    mANRPA.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么在 kotlin 你这要这样写就行了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mANRPA?.stop()</span><br></pre></td></tr></table></figure></p>
<p>使用 ?.  的效果和上面的 java 代码是一样的，表示该变量可能为空，如果不为空则执行后面的表达式。<br>参考地址：<a href="https://www.kotlincn.net/docs/reference/null-safety.html" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/null-safety.html</a></p>
<h2 id="开发效率和生态环境"><a href="#开发效率和生态环境" class="headerlink" title="开发效率和生态环境"></a>开发效率和生态环境</h2><ul>
<li><strong>Kotlin 有助于提升团队开发效率</strong>。通过比较 Kotlin 文件和 Java 文件内的平均代码行数，您会发现 Kotlin 可以缩减至少 25% 的代码行数。写的代码少了，测试和维护的的时间成本就会相应降低，团队开发新特性的速度自然也就上去了。此外，您还可以观察一下如果用 Kotlin 和 Java 开发类似的特性，哪种语言的用时会更短。</li>
<li><strong>Kotlin 有助于改善应用质量</strong>。除了大家熟知的空安全 (null-safety) 特性以外，Kotlin 还提供了许多其它的安全特性，帮助您避免各种类型的代码错误。Pinterest 建议开发者在应用程序迁移的过程中，跟踪记录每个模块的代码错误率。您可以发现错误率呈下降趋势。请点击观看 <a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652047108&amp;idx=3&amp;sn=5d5d507ba63eb97ce7cd698dc1353883&amp;chksm=808ca741b7fb2e577ad6cce7781010b52772ede2d70d551e5dea130caf8a3040e132c086b976&amp;token=1188893980&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">Android 开发者故事</a> 对 Camera360 的专访，或者阅读近期学术研究，进一步了解 Kotlin 如何提高代码质量。</li>
<li><strong>Kotlin 是行业趋势所在</strong>。在 Google Play Top 1000 榜单中，使用 Kotlin 开发的 Android 应用占比达到 26％，其中包括 Twitter、Pinterest、微信、美国运通卡等超重量级应用。Redmonk 公布的榜单显示 Kotlin 是目前发展第二快的的移动平台编程语言。科技媒体 Dice 也曾发文指出 Kotlin 的相关工作数量呈爆炸式增长。</li>
<li><strong>otlin 让您的团队更开心</strong>。虽然幸福感很难量化，但是您可以通过适当的方式让管理层体会到团队对 Kotlin 的热爱。根据《 StackOverflow 2018 年度开发者调查报告》显示，Kotlin 是目前第二大最受欢迎的编程语言</li>
</ul>
<p>以上总结，摘抄自官方说明。<br><strong>根据过去的一年多的实践和推广，kotlin 的 0 吐槽</strong>的。</p>
<h2 id="java-语法完全兼容-kotlin"><a href="#java-语法完全兼容-kotlin" class="headerlink" title="java 语法完全兼容 kotlin"></a>java 语法完全兼容 kotlin</h2><p>你可以通过几个小时学习 kotlin 的基础语法，包括：</p>
<p>1.怎么定义变量<br>2.怎么定义方法<br>3.怎么定义类<br>4.等等……</p>
<p>然后就可以像 java 一样使用 kotlin，当然这不是我们的最终目的，因为 kotlin 的语法糖才是我们最后的目标。<br>google 发布了 kotlin 简易教程，大概只需要几个小时，就可以看完：<br><a href="https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652046391&amp;idx=1&amp;sn=46efa48076a4533f355af6351b76c012&amp;chksm=808ca472b7fb2d64afc89edf6beba1540e5a6ff49ad6346bd5d72b3957fa5f9323e07b8aab03&amp;mpshare=1&amp;scene=21&amp;srcid=1012DUvvfamUABt1Dal4y9Yj&amp;pass_ticket=xmwlmoT/9YpfUnTCXQKhaLOa3Tx7fxw22AlDz%20lYR5ZOaBLOxqpga4QUU7FmSSGF#wechat_redirect" target="_blank" rel="noopener">几小时上手 kotlin</a><br>在实际的开发中，大概第一个星期内，你写代码的速度会下降一些，但是一个星期之后，完全上手了，写代码的速度是有很大的提升的。</p>
<h2 id="kotlin-高级语法-语法糖示例"><a href="#kotlin-高级语法-语法糖示例" class="headerlink" title="kotlin 高级语法(语法糖示例)"></a>kotlin 高级语法(语法糖示例)</h2><h4 id="1-extension-扩展函数和扩展属性"><a href="#1-extension-扩展函数和扩展属性" class="headerlink" title="1.extension-扩展函数和扩展属性"></a>1.extension-扩展函数和扩展属性</h4><p>关于 扩展函数的说明：<a href="https://www.kotlincn.net/docs/reference/extensions.html" target="_blank" rel="noopener">中文教程</a>  <a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="noopener">英文教程</a><br>android ktx 库提供了一系列的优秀的扩展函数 <a href="https://android.github.io/android-ktx/core-ktx/index.html" target="_blank" rel="noopener">官方说明</a><br>简单的说，扩展函数是什么呢？先来看一个例子，在java 里面 你要 remove 一个 View 的 Parent，你可能会这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(mLoadingView.getParent() != null)&#123;</span><br><span class="line">    ((ViewGroup)mLoadingView.getParent()).removeView(mLoadingView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是每次都这样写，貌似比较重复，对吧；然后你就可能考虑写一个静态方法，类似如下，比如在 ViewUtils 类似命名里写一个静态函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void removeSelf(View view)&#123;</span><br><span class="line">    if(view == null) return;</span><br><span class="line">    if(view.getParent() != null)&#123;</span><br><span class="line">        ((ViewGroup)view.getParent()).removeView(view);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是在 kotlin 中，使用扩展函数，可以更巧妙更直接的实现这个功能。<br>写在某个文件里面，编写一个顶级的扩展函数，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">inline fun View.removeSelf(): Boolean &#123;</span><br><span class="line">    if (this.parent != null &amp;&amp; this.parent is ViewGroup) &#123;</span><br><span class="line">        (this.parent as ViewGroup).removeView(this)</span><br><span class="line">        return true</span><br><span class="line">    &#125;</span><br><span class="line">    return false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在需要调用的地方，你直接这样写就行了：`<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTopBar?.removeSelf()</span><br></pre></td></tr></table></figure></p>
<p>当然 kotlin 扩展函数的作用并不仅仅在此，它的思想主要是丰富实际类的语法。<br>例如，现在让你设计一个功能，点击一个按钮，然后发起一个网络请求，但是需要注意在 View 的生命周期内，如果View 销毁了，取消这个网络请求，并且不会更新UI。那么常规的 java 代码，写起来可能就是一堆的回调，但是使用 kotlin 的 扩展函数+代理，封装之后，你看到的就是下面一行代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//这里封装了 onClick() 方法，详细的细节，后面会介绍</span><br><span class="line">mJumpBitmap.onClickAutoDisposable &#123; </span><br><span class="line">    //这里是你的网络请求操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-Delegate-And-Delagate-Properties-委托以及委托属性"><a href="#2-Delegate-And-Delagate-Properties-委托以及委托属性" class="headerlink" title="2.Delegate And Delagate Properties -委托以及委托属性"></a>2.Delegate And Delagate Properties -委托以及委托属性</h4><p>代理在设计模式上是非常优秀的，例如 retrofit 框架里，大量的使用动态代理这种设计模式；然后 kotlin 在语法层面去支持了代理，包括代理和代理属性。<br>代理属性的话，kotlin 支持一些标准的代理属性,例如 by lazy，Observable,Storing;其中 by lazy，提供三种类型的懒加载，包括非线程安全，synchronized 同步线程安全，以及cas 操作线程安全。<br>示例如下,例如在 PushProto.java 中，需要对 ProtoBuf 解析单例进行初始化，并且要求是线程安全的，原先 java 代码如下，也就是一个 double check 的单例模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//double check 的单例模式，这里的 volatile 是为了防止指令重排</span><br><span class="line">private static volatile com.google.protobuf.Parser&lt;PushProto&gt; PARSER;</span><br><span class="line">//这里省略一些代码</span><br><span class="line">if (PARSER == null) &#123;    synchronized (com.yy.hiyo.proto.PushProto.class) &#123;</span><br><span class="line">   if (PARSER == null) &#123;</span><br><span class="line">       PARSER = new DefaultInstanceBasedParser(DEFAULT_INSTANCE);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果是用 kotin 则只需要使用 by lazy 懒加载委托属性便能实现类似的效果，kotlin 代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//by lazy 支持泛型，后面的泛型是 initProtoInstance 的类型</span><br><span class="line">val initProtoInstance by lazy&lt;DefaultInstanceBasedParser&gt; &#123;</span><br><span class="line">  //这里其实就是返回值</span><br><span class="line">    DefaultInstanceBasedParser();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意:实际上这里使用的并非是是 double check 的模式，而是类似的一种线程安全模式，源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//by lazy 默认是 SynchronizedLazyImpl 模式</span><br><span class="line">public fun &lt;T&gt; lazy(initializer: () -&gt; T): Lazy&lt;T&gt; = SynchronizedLazyImpl(initializer)</span><br><span class="line"></span><br><span class="line">@kotlin.jvm.JvmVersion</span><br><span class="line">public fun &lt;T&gt; lazy(mode: LazyThreadSafetyMode, initializer: () -&gt; T): Lazy&lt;T&gt; =</span><br><span class="line">        when (mode) &#123;</span><br><span class="line">            LazyThreadSafetyMode.SYNCHRONIZED -&gt; SynchronizedLazyImpl(initializer)</span><br><span class="line">            LazyThreadSafetyMode.PUBLICATION -&gt; SafePublicationLazyImpl(initializer)</span><br><span class="line">            LazyThreadSafetyMode.NONE -&gt; UnsafeLazyImpl(initializer)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">private class SynchronizedLazyImpl&lt;out T&gt;(initializer: () -&gt; T, lock: Any? = null) : Lazy&lt;T&gt;, Serializable &#123;</span><br><span class="line">    private var initializer: (() -&gt; T)? = initializer</span><br><span class="line">    @Volatile private var _value: Any? = UNINITIALIZED_VALUE</span><br><span class="line">    // final field is required to enable safe publication of constructed instance</span><br><span class="line">    private val lock = lock ?: this</span><br><span class="line"></span><br><span class="line">    override val value: T</span><br><span class="line">        get() &#123;</span><br><span class="line">            val _v1 = _value</span><br><span class="line">            if (_v1 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                @Suppress(&quot;UNCHECKED_CAST&quot;)</span><br><span class="line">                return _v1 as T</span><br><span class="line">            &#125;</span><br><span class="line">            return synchronized(lock) &#123;</span><br><span class="line">                val _v2 = _value</span><br><span class="line">                if (_v2 !== UNINITIALIZED_VALUE) &#123;</span><br><span class="line">                    @Suppress(&quot;UNCHECKED_CAST&quot;) (_v2 as T)</span><br><span class="line">                &#125;</span><br><span class="line">                else &#123;</span><br><span class="line">                    val typedValue = initializer!!()</span><br><span class="line">                    _value = typedValue</span><br><span class="line">                    initializer = null</span><br><span class="line">                    typedValue</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>by lazy 的三种模式如下：</p>
<p>1.LazyThreadSafetyMode.<strong>SYNCHRONIZED</strong> 类似 double check 线程安全，synchronized 悲观锁<br>2.LazyThreadSafetyMode.<strong>PUBLICATION</strong> 线程安全，使用 cas 锁，多个线程可以同时执行初始化代码块，但是只返回第一个执行完成的数值，作为初始化<br>3.LazyThreadSafetyMode.<strong>NONE</strong> 单线程先可用，等于 java 懒汉式单例</p>
<p>其后，其它两种标准属性，参考官方教程。</p>
<h4 id="3-语法层面支持懒加载-by-lazy-和-lateinit"><a href="#3-语法层面支持懒加载-by-lazy-和-lateinit" class="headerlink" title="3.语法层面支持懒加载-by lazy 和 lateinit"></a>3.语法层面支持懒加载-by lazy 和 lateinit</h4><p>懒加载是经常使用的一个功能，传统的 java 懒加载，可能是在使用的是判断一下对象是否为空，但是在 kotlin 里，提供了语法层次的懒加载，表示该变量在使用之前一定会被<code>初始化</code>。<br>by-lazy 上面说到了，lateinit 简单用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lateinit var mStirng: String</span><br><span class="line"></span><br><span class="line">//初始化的时候，直接赋值</span><br><span class="line">mString = &quot;some&quot;</span><br><span class="line"></span><br><span class="line">//使用的时候，可以先判断是否初始化</span><br><span class="line">if(TestActivity::mStirng.isLateinit)&#123;</span><br><span class="line">  //这里表示初始化过了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-比-java-更强大的类型判断"><a href="#4-比-java-更强大的类型判断" class="headerlink" title="4.比 java 更强大的类型判断"></a>4.比 java 更强大的类型判断</h4><p>在 java 中，泛型和反射都是使用频率极高的语法，使用泛型或者接口编程之后，我们经常要使用 instance of 做判断，如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (instance instanceof BasePresenter) &#123;</span><br><span class="line">    ((BasePresenter) instance).onInit(mMvpContext); // 2. init</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在kotlin 里面，只需要写如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Any 类型，等于 java  Object 类型</span><br><span class="line">fun checkSting(content:Any)&#123;</span><br><span class="line">  //kotlin 用 is 判断是否一种类型，等于 instance</span><br><span class="line">    if(content is String)&#123;</span><br><span class="line">      //这里之后 content 会智能 转换为 String，并不需要 java 那种强转，编译器会自动识别</span><br><span class="line">        content.substring(1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在泛型和接口编程使用广泛的情况下，kotlin 的类型安全存在以下优势：</p>
<ul>
<li>is 操作符，支持非操作，比 java 更简洁，在语法层次表面的 非该类型；其次 is 类型判断符，作用域类，类型会智能转换，也就是例子中说的。需要注意是，val 和 var 类型，支持的 is 操作不一样。</li>
<li>as 操作符，支持空类型转换，也就是 as？，可以转换为 String? 等可空类型，类似 java 操作是 先要判断该对象是否为该类型，然后强转，语法比较绕，然而 kotlin 直接支持可为空类型的转换</li>
</ul>
<h4 id="5-functions-and-lambdas-函数和-lambdas-表达式"><a href="#5-functions-and-lambdas-函数和-lambdas-表达式" class="headerlink" title="5.functions and lambdas - 函数和 lambdas 表达式"></a>5.functions and lambdas - 函数和 lambdas 表达式</h4><p>在 kotlin 里面函数是第一公民，java 8 也把加入了该特性，但是远远没有 kotlin 的函数功能强大，kotlin 的函数功能如下：</p>
<ul>
<li>参数值和变量可以是函数</li>
<li>函数参数支持默认参数</li>
<li>支持命名参数</li>
<li>支持 lambda</li>
<li>支持内联函数</li>
<li>支持强大的扩展函数</li>
<li>编译器支持内联优化</li>
<li>函数可以有一个接收者</li>
</ul>
<p>函数和 lambdas 表达式对实际开发带来极大的方便，也丰富了编程思想，更多的细节，可以参考官方教程。</p>
<h4 id="6-强大的集合功能"><a href="#6-强大的集合功能" class="headerlink" title="6.强大的集合功能"></a>6.强大的集合功能</h4><p>在 kotlin stdlib 里面，支持了强大的集合功能，支持各种高阶函数,主要的高阶函数如下：</p>
<ul>
<li>分组 sort</li>
<li>映射 map</li>
<li>排序 sort</li>
<li>等等</li>
</ul>
<p>具体可以参考一个专栏 <a href="https://zhuanlan.zhihu.com/LearningKotlin" target="_blank" rel="noopener">kotlin 学习之路</a><br>或者可以直接在 AS 里面搜索类 _Collection.kt，里面可以看到该类的所有的高阶函数<br>下面是一个简单的示例，比如你在 java 中需要对一个后端返回的 List 进行排序，java 中常见的实现方案有</p>
<p>1.ollections 中<code>static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</code>传入该 List，但是 List 中的元素需要实现 Comarable 接口，并且重写 compareTo()方法<br>2.Collection中，<code>static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code>入该 List 和 一个Comparator。</p>
<p>3.java 中，支持 lambda 表达式之后，你可以这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ballList.sort(Comparator.comparing(Ball::getHits));</span><br></pre></td></tr></table></figure></p>
<p>表示使用 Ball 的 hits 字段进行比较</p>
<p>4.java 8 中可以使用 stream</p>
<p>如果使用 kotlin，这里支持各种各样的sort() 方式，如下 api：<br><img src="/2019/05/14/kotlin概览以及团队实践/e2dd4f41.webp" alt=""><br>那么上面的例子中，kotlin 中这个排序只要使用 Collections 里面的扩展函数就可以做了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//使用 hits 字段，做降序处理，Collections.sort() 中默认是升序的</span><br><span class="line">ballList.sortByDescending &#123;it.hits&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以其实写到这里，我们已经见识到了，kotlin 的开发者帮助我们考虑了各种语法场景，我们站立在一个伟大的开发团队上，自然而然能更快的写出更高质量的代码。</p>
<h4 id="7-Standard-Lib标准库"><a href="#7-Standard-Lib标准库" class="headerlink" title="7.Standard Lib标准库"></a>7.Standard Lib标准库</h4><p>Kotlin的标准库提供了一系列提高开发效率的函数，例如 apply{} ，run{},let{} 等，这里的解释都比较简单，具体自己看一下 api 就行了,位于 Standard.kt 文件中，使用例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EnterRoomConfig.RoomlistEventBean eventBean = new EnterRoomConfig.RoomlistEventBean();</span><br><span class="line">eventBean.setColumn(String.valueOf(position + 1));</span><br><span class="line">eventBean.setRow(baseRoomEventListBean.getRow());</span><br><span class="line">eventBean.setPositionId(String.valueOf(position + 1));</span><br><span class="line">eventBean.setToken(token);</span><br><span class="line">eventBean.setModelId(baseRoomEventListBean.getModelId());</span><br></pre></td></tr></table></figure></p>
<p>你可能不断的为访问 java bean 或者某个对象的属性或者方法，则需要不停的写 对象实例.属性 或者 对象实例.方法。在 kotlin 中，你完全可以释放自己的双手，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">val enterRoomConfig = EnterRoomConfig(&quot;&quot;).apply &#123;</span><br><span class="line">  //这里有个 this 指向前面new 出来的 EnterRoomConfig() 实例</span><br><span class="line">  //其实等于 this.isGuideEnter </span><br><span class="line">    isGuideEnter = false</span><br><span class="line">    isQuickMatch = true</span><br><span class="line">    followUid = followUid</span><br><span class="line">    pwd_token = &quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>apply() 的源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123;</span><br><span class="line">    contract &#123;</span><br><span class="line">        callsInPlace(block, InvocationKind.EXACTLY_ONCE)</span><br><span class="line">    &#125;</span><br><span class="line">    block()</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里包含，contract 用法和 带接受者的函数，block() 函数的接收者是T，kotlin 这里其实是提供了一种方便的建造者模式，在 java 里面，你实现建造者模式，需要自己手动去编写接口和 Builder 实现，在 kotlin 则使用这些高阶函数，方便你随意的实现 Builder 模式。</p>
<h4 id="8-编写单例更快了"><a href="#8-编写单例更快了" class="headerlink" title="8.编写单例更快了"></a>8.编写单例更快了</h4><p>你只需要使用 Object  就可以编写单例了，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">object CloUtils &#123;</span><br><span class="line">    fun test()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么kotlin 上的单例和 java 的各种单例模式，性能上有什么区别吗？kotlin 使用 object 关键字声明的单例，翻译成 java 如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ublic final class CloUtils &#123;</span><br><span class="line">   public static final CloUtils INSTANCE;</span><br><span class="line"></span><br><span class="line">   public final void test() &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   static &#123;</span><br><span class="line">      CloUtils var0 = new CloUtils();</span><br><span class="line">      INSTANCE = var0;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是 java 常见的类似 饿汉式的单例，这种单例是线程安全的，可能存在一定问题：</p>
<p>1.在类加载的时候，单例会被初始化，所以不要在初始化代码块，做太多操作</p>
<p>2.不能直接在构造函数传递参数，其实是 object 不能够有一个 constractor<br><img src="/2019/05/14/kotlin概览以及团队实践/3ba8f41.webp" alt=""><br>那么实际上我们可以使用其它方式实现我们需要的效果，例如 懒汉式和 double check 等模式，类似 by lazy。</p>
<h4 id="9-kotlin-和-android-android-extension插件"><a href="#9-kotlin-和-android-android-extension插件" class="headerlink" title="9.kotlin 和 android-android extension插件"></a>9.kotlin 和 android-android extension插件</h4><p>实际上，kotlin 是一门全栈的语言，可以写基于 jvm 的，例如 android 和 后端，也可以写前端，但是在 android 上的表现，可能是最亮眼的，如是说：<br>在某个 module 的 gradle 文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;kotlin-android-extensions&apos;</span><br></pre></td></tr></table></figure></p>
<p>然后你就可以使用 android extension 全家桶了，可以帮你做啥呢？</p>
<ul>
<li>View Binding 取代繁琐的 findViewById()方法<br>例如某段 java 代码：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//数据域声明各种View</span><br><span class="line">private YYTextView titleTv, roomNameTv, onlineTv, tagTv;</span><br><span class="line">private YYImageView moreIv, lockIv;</span><br><span class="line">private YYLinearLayout titleLayout;</span><br><span class="line">private ViewGroup onlineCountLayout;</span><br><span class="line">private BubblePopupWindow mPopupWindow;</span><br><span class="line"></span><br><span class="line">//然后各种 findViewByID</span><br><span class="line">titleTv = findViewById(R.id.tv_title_when_popup);</span><br><span class="line">titleLayout = findViewById(R.id.layout_title_main);</span><br><span class="line">roomNameTv = findViewById(R.id.tv_room_name);</span><br><span class="line">onlineTv = findViewById(R.id.tv_online_count);</span><br><span class="line">tagTv = findViewById(R.id.tv_tag);</span><br><span class="line">moreIv = findViewById(R.id.iv_more);</span><br><span class="line">lockIv = findViewById(R.id.iv_lock);</span><br><span class="line">onlineTv.setTypeface(FontUtils.getTypeFace(FontUtils.FontType.DINMittelschriftAlternate));</span><br><span class="line">roomNameTv.setOnClickListener(this);</span><br><span class="line">tagTv.setOnClickListener(this);</span><br><span class="line">findViewById(R.id.iv_back).setOnClickListener(this);</span><br><span class="line">moreIv.setOnClickListener(this);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在 kotlin 中，你使用 extension 插件，就可以在这样访问控件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//如果你使用了 extension 插件，这句话会自动 import 进来</span><br><span class="line">import kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"></span><br><span class="line">class MainActivity : AppCompatActivity() &#123;</span><br><span class="line">    val tag = &quot;MainActivity&quot;</span><br><span class="line"></span><br><span class="line">    @RequiresApi(Build.VERSION_CODES.JELLY_BEAN)</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        initBut()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private fun initBut()&#123;</span><br><span class="line">      //使用的时候，直接用 View 的ID 就行了，xml 代码看下面</span><br><span class="line">        mJumpBitmap.setOnClickListener &#123;</span><br><span class="line">            val intent = Intent(this@MainActivity, BitmapAcitivty::class.java)</span><br><span class="line">            startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">        mJumpFresco.setOnClickListener &#123;</span><br><span class="line">            val intent = Intent(this@MainActivity, FrescoRecyvlerActivity::class.java)</span><br><span class="line">            startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>原理很简单，就是 extension 插件帮你 findViewById 了类似其它注入框架。<br>这里有几点注意的，你可以在 Activity 或者 Fragment 或者自定义View 或者 ViewHolder 里面使用这个特性，无需任何其它操作。其次 这个是有Cache 的，每次直接访问id，并不会每次都去 findViewById,只要第一次才会 findViewByID,然后后面会存起来。</p>
<ul>
<li>使用注解实现 Pracelable<br>在实际开发中，你可以给一个类实现系列化，但是中途可能增加字段，传统的 java 编写中，或者使用 ide 插件编写，增加字段也是非常辛苦，需要在 writeToParcel() 和  createFromParcel() 方法添加代码，如果使用 extension 插件，只需要开启这个设置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &apos;com.android.application&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android&apos;</span><br><span class="line">apply plugin: &apos;kotlin-android-extensions&apos;</span><br><span class="line">//在 build.gradle</span><br><span class="line">android &#123;</span><br><span class="line">    .......</span><br><span class="line">    androidExtensions&#123;</span><br><span class="line">        experimental = true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后在实现 Parcelable 的类上增加一个注解 @Parcelize,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Parcelize</span><br><span class="line">data class Ball(var hits: Int) : Parcelable &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上，gradle 插件会为你自动加上  Parcelable 的实现。</p>
<ul>
<li>还有其它 experimental 的特性等待你去挖掘</li>
</ul>
<p>参考文档：<a href="https://kotlinlang.org/docs/tutorials/android-plugin.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/tutorials/android-plugin.html</a></p>
<h2 id="kotlin-Coroutine-kotlin-协程库"><a href="#kotlin-Coroutine-kotlin-协程库" class="headerlink" title="kotlin Coroutine -kotlin 协程库"></a>kotlin Coroutine -kotlin 协程库</h2><p>Coroutine 协程，是kotlin 上的一个轻量级的线程库，对比 java 的 Executor，主要有以下特点：</p>
<ul>
<li>更轻量级的 api 实现协程</li>
<li>async 和 await 不作为标准库的一部分</li>
<li>suspend 函数，也就是挂起函数是比 java future 和 promise 更安全并且更容易使用</li>
</ul>
<p>那么实际本质上和线程池有什么区别呢？我的理解是这样的，协程是在用户态对线程进行管理的，不同于线程池，协程进一步管理了不同协程切换的上下文，协程间的通信，协程挂起，对于线程挂起，粒度更小，而且一般不会直接占用到CPU 资源，所以在编程发展的过程中，广义上可以认为 多进程-&gt;多线程-&gt;协程。<br>协程并不会映射成内核线程或者其他这么重的资源，它的调度在用户态就可以搞定，任务之间的调度并非抢占式，而是协作式的。</p>
<h2 id="Kotlin-anko-在代码中使用-dsl-编写布局"><a href="#Kotlin-anko-在代码中使用-dsl-编写布局" class="headerlink" title="Kotlin -anko 在代码中使用 dsl 编写布局"></a>Kotlin -anko 在代码中使用 dsl 编写布局</h2><p>anko 库，你可以在在代码中编写布局，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//这里是一个垂直布局的LinearLayout </span><br><span class="line">verticalLayout &#123;</span><br><span class="line">    backgroundColor = Color.parseColor(&quot;#eeeeee&quot;)</span><br><span class="line">    layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样的 anko 这边有个插件，可以支持实时预览-你需要在编写代码之后，build 一下，然后就可以预览布局。<br><strong>由于anko 存在预览问题，并且层级嵌套的时候，不好优化，所以暂时不建议使用 anko 去编写布局</strong></p>
<h2 id="如何理解-kotlin-语法糖"><a href="#如何理解-kotlin-语法糖" class="headerlink" title="如何理解 kotlin 语法糖"></a>如何理解 kotlin 语法糖</h2><p>对于 java 的程序员，kotlin 开发者提供了一种方式，帮助开发者去理解 kotlin，也就是可以把 kotlin 编译出来的字节码，反翻译成 java 代码，具体操作 tools-show kotlin bytecod-然后在右侧会看到 kotlin 文件编译之后的字节码文件-然后点击Decompile ,接着就可以看到 kotlin “翻译出”java 的文件，之前讲述 编写单例模块里面，就是一个例子。</p>
<h2 id="旧的-java-代码怎么办"><a href="#旧的-java-代码怎么办" class="headerlink" title="旧的 java 代码怎么办"></a>旧的 java 代码怎么办</h2><p>一段时间之后，大家写 kotlin 都写得很爽了，那么总是有一个旧的代码是用 java 写的，那怎么办？如果你想把 java 改成 kotlin，也很简单：<br>选中你的 java 文件，点击 AS 导航栏 code-covert Java File To Kotlin File,这样就可以转过去了，然后进行简单的修改，也就是把一些报错和 waring 去掉(一般不会有报错)。转换之后的文件可以完美的运行的，这个你不用担心。<br><img src="/2019/05/14/kotlin概览以及团队实践/c3e4f56e.webp" alt=""></p>
<h2 id="Kotlin-的坑"><a href="#Kotlin-的坑" class="headerlink" title="Kotlin 的坑"></a>Kotlin 的坑</h2><p>当然 在使用 kotlin 过程中，会发现一些问题或者成本。</p>
<h2 id="成本问题"><a href="#成本问题" class="headerlink" title="成本问题"></a>成本问题</h2><p>对个人而言：</p>
<ul>
<li>你需要花费一天时间学习 kotlin 语法</li>
<li>你需要花费一两周的时间学习 kotlin 对应的 api</li>
<li>使用高阶函数或者 Coroutine 库，等于新使用的一个框架的成本</li>
</ul>
<p>第一周使用 kotlin 在你的工作中，你会觉得效率下降，而且有点不知所措，甚至有点抵抗 kotlin，但是在两三个星期之后，你一定是这样的：<br><img src="/2019/05/14/kotlin概览以及团队实践/1111.jpg" alt=""></p>
<p>对于团队而言</p>
<ul>
<li>包大小变大了</li>
<li>构建时间会增加一点点</li>
</ul>
<p>针对问题二，kotlin 的开发者正在优化，同时我们可以在构建的时候，监听构建task 花费的时间，让数据去评测，是否值得引入 kotlin。<br>选取了某个项目中的 module ，该 module 的基本为 kotlin 代码编写，使用 kotlin 构建时间增加了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    1% :app:kaptGener…ReleaseKotlin (0:07.775)</span><br><span class="line">    1% :app:kaptReleaseKotlin (0:05.872)</span><br><span class="line">▇  2% :app:compileReleaseKotlin (0:21.167)</span><br></pre></td></tr></table></figure></p>
<p>如果是 java 代码的话，上述的时间可能是一半(猜测是这样的)，但是从实际数据看，该 module 有几百个 kotlin 文件，编译所花费的时间，也不过是增加了十几秒，所以并不是特别大的问题。</p>
<h2 id="java-和-kotlin-互调"><a href="#java-和-kotlin-互调" class="headerlink" title="java 和 kotlin 互调"></a>java 和 kotlin 互调</h2><h4 id="1-java-null-问题"><a href="#1-java-null-问题" class="headerlink" title="1.java null 问题"></a>1.java null 问题</h4><p>习惯写 java 的同学，一般是不会写这样的声明的,去声明一个参数是可为空的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun printSome(content:String?)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般你是这样声明的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun printSome1(content:String)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 kotlin 里面，是没问题的，即便是你传入 null，编译器也会提示你，不可以传入null，但是一旦在 java 去调用这个 printSome1() 方法，一旦你传入了 null，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//java 调用 kotlin </span><br><span class="line">CloUtils.INSTANCE.printSome1(null);</span><br></pre></td></tr></table></figure></p>
<p>依旧是ok的，但是一旦运行的时候，就会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">2019-05-05 11:09:05.705 11674-11674/com.yy.yylite.kotlinshare E/AndroidRuntime: FATAL EXCEPTION: main</span><br><span class="line">   Process: com.yy.yylite.kotlinshare, PID: 11674</span><br><span class="line">   java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.yy.yylite.kotlinshare/com.yy.yylite.kotlinshare.bitmapcompress.BitmapAcitivty&#125;: java.lang.IllegalArgumentException: Parameter specified as non-null is null: method kotlin.jvm.internal.Intrinsics.checkParameterIsNotNull, parameter content</span><br><span class="line">       at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2740)</span><br><span class="line">       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2801)</span><br><span class="line">       at android.app.ActivityThread.-wrap12(ActivityThread.java)</span><br><span class="line">       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1548)</span><br><span class="line">       at android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">       at android.os.Looper.loop(Looper.java:163)</span><br><span class="line">       at android.app.ActivityThread.main(ActivityThread.java:6368)</span><br><span class="line">       at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:901)</span><br><span class="line">       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:791)</span><br><span class="line">    Caused by: java.lang.IllegalArgumentException: Parameter specified as non-null is null: method kotlin.jvm.internal.Intrinsics.checkParameterIsNotNull, parameter content</span><br><span class="line">       at com.yy.yylite.kotlinshare.collectionutils.CloUtils.printSome1(CloUtils.kt)</span><br><span class="line">       at com.yy.yylite.kotlinshare.flow.ff.testJavaCallKotlin(ff.java:31)</span><br><span class="line">       at com.yy.yylite.kotlinshare.bitmapcompress.BitmapAcitivty.onCreate(BitmapAcitivty.kt:29)</span><br><span class="line">       at android.app.Activity.performCreate(Activity.java:6861)</span><br><span class="line">       at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1119)</span><br><span class="line">       at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2693)</span><br><span class="line">       at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2801) </span><br><span class="line">       at android.app.ActivityThread.-wrap12(ActivityThread.java) </span><br><span class="line">       at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1548) </span><br><span class="line">       at android.os.Handler.dispatchMessage(Handler.java:102) </span><br><span class="line">       at android.os.Looper.loop(Looper.java:163) </span><br><span class="line">       at android.app.ActivityThread.main(ActivityThread.java:6368) </span><br><span class="line">       at java.lang.reflect.Method.invoke(Native Method) </span><br><span class="line">       at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:901) </span><br><span class="line">       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:791)</span><br></pre></td></tr></table></figure></p>
<p>具体的原因在于，编译器层会帮我们加这样一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Intrinsics.checkParameterIsNotNull(content, &quot;content&quot;);</span><br></pre></td></tr></table></figure></p>
<p>如果传入的参数为 null，则会直接抛出一个异常。<br>同样的，在 kotlin 里面，如果执行这样的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var nonNullStr:String = null // 不允许的，如果是运行期赋值，则会报错</span><br></pre></td></tr></table></figure></p>
<h4 id="2-java-方法-Exception-问题"><a href="#2-java-方法-Exception-问题" class="headerlink" title="2.java 方法 Exception 问题"></a>2.java 方法 Exception 问题</h4><p>在之前某次迭代中，A  同学写了这样一行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.....</span><br><span class="line">val gson = Gson()</span><br><span class="line">fastSpeech!!.words = gson.fromJson(words, object : TypeToken&lt;List&lt;String&gt;&gt;() &#123;</span><br><span class="line">&#125;.type)</span><br><span class="line"> hotWordPopupWindow?.setData(fastSpeech!!.words, fastSpeech!!.classId)</span><br><span class="line">....</span><br></pre></td></tr></table></figure></p>
<p>作为一个老道的程序员都知道,使用 GSON 的方法，没有 try catch 是不安全的，何况 fromJson 方法签名就有 throw 异常的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; T fromJson(JsonElement json, Type typeOfT) throws JsonSyntaxException &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>然而你使用 java 的时候，编译器会提示你需要 catch 异常，但是在 kotlin 里面，确实不会有的。<br>原因是因为 kotlin 开发者，认为所有的 Exception 都是 unchecked 的，编译器不会提示你 catch 住，但是在过去的 java 开发里面，effect java 认为，处理 checked Exception 是优雅合理的；<br>原文如下：<br>Checked Exceptions<br>In Kotlin, all exceptions are unchecked, meaning that the compiler does not force you to catch any of them. So, when you call a Java method that declares a checked exception, Kotlin does not force you to do anything。<br>在过去的实践里发现，在处理 json，网络，IO  的时候，需要开发者关注，是否需要 try catch，当然了，这可能也是一个好处，毕竟写代码的人关心的细节更多了。<br>关于 java 和 kotlin 互调参考 <a href="https://kotlinlang.org/docs/reference/java-interop.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/java-interop.html</a></p>
<h2 id="如何推动kotlin普及"><a href="#如何推动kotlin普及" class="headerlink" title="如何推动kotlin普及"></a>如何推动kotlin普及</h2><p>需要团队成员去学习官网教程 或者 google 提供的快速学习的教程，当然这里只是快速浏览就行了，主要还是得靠实践，先熟悉基本的语法，然后找时间对语法糖进行了解，最后在实践开发中使用高阶特性。<br>官网教程-中文 <a href="https://www.kotlincn.net/docs/reference/" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/</a><br>官网教程-英文<a href="https://kotlinlang.org/docs/reference/basic-types.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/basic-types.html</a><br>快速入门教程 几小时上手 kotlin<br>挺不错的一个教程 EasyKotlin<br>然后可以在一段时间内需要通过 review 代码，提高大家对 kotlin 的认识和用法，大概持续一个开发周期，之后基本可以很顺畅的写代码了。<br>最后就是规则~怎么让 java 和 kotlin  共存</p>
<p>1.新文件，尽量用 kotlin 写<br>2.旧的 java 文件，可以先用 java 写，有时间再把 java 转成 kotlin</p>
<p>最后就是 IDE 对 kotlin 的友好支持，就是你在 commit 的时候，会对代码进行一个 增量的 code analyse，然后虎会给出你一个更好的建议，其中就包括 kotlin 语法的纠正。如下展示：</p>
<p><img src="/2019/05/14/kotlin概览以及团队实践/f31e1a78.webp" alt=""><br>然后点击 commit 之后，点击review<br><img src="/2019/05/14/kotlin概览以及团队实践/27c5ae.webp" alt=""><br>最后 IDE 会给出更 合理的代码提示，一般可以改的尽量改一下，如下，这里提示这一行命名是多余的：<br><img src="/2019/05/14/kotlin概览以及团队实践/9e31dd63.webp" alt=""></p>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://yoursite.com/2019/05/14/kotlin概览以及团队实践/" data-id="cjzfem5kj009kk0fvekt7u592" class="article-share-link"><i class="fa fa-share"></i>分享到</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>关注我 :</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="qq" href="http://wpa.qq.com/msgrd?v=3&uin=1466132938&site=qq&menu=yes" target="_blank" rel="noopener">
                          <i class="icon fa fa-qq"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2019/05/22/Jquery中-bind-live-delegate和on之间的区别详解/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">下一篇</strong>
        <p class="article-nav-title">
        
            Jquery中.bind,live,delegate和on之间的区别详解
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2019/05/13/JSP的内置对象/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">上一篇</strong>
        <p class="article-nav-title">JSP的内置对象</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/08/17/推荐几个IDEA插件/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/08/17/推荐几个IDEA插件/0817183002.png)" alt="推荐几个IDEA插件" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/推荐好文/">推荐好文</a></p>
                            <p class="item-title"><a href="/2019/08/17/推荐几个IDEA插件/" class="title">推荐几个IDEA插件</a></p>
                            <p class="item-date"><time datetime="2019-08-17T10:23:26.000Z" itemprop="datePublished">2019-08-17</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/08/17/IDEA从入门到癫狂/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/08/17/IDEA从入门到癫狂/7165751.jpg)" alt="IDEA从入门到癫狂" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/推荐好文/">推荐好文</a></p>
                            <p class="item-title"><a href="/2019/08/17/IDEA从入门到癫狂/" class="title">IDEA从入门到癫狂</a></p>
                            <p class="item-date"><time datetime="2019-08-17T08:55:50.000Z" itemprop="datePublished">2019-08-17</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/08/16/几款主流JSON库性能对比/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/08/16/几款主流JSON库性能对比/94444.jpg)" alt="几款主流JSON库性能对比" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"></p>
                            <p class="item-title"><a href="/2019/08/16/几款主流JSON库性能对比/" class="title">几款主流JSON库性能对比</a></p>
                            <p class="item-date"><time datetime="2019-08-16T08:01:59.000Z" itemprop="datePublished">2019-08-16</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/08/15/7种JVM垃圾收集器的对比/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/08/15/7种JVM垃圾收集器的对比/154645.jpg)" alt="7种JVM垃圾收集器的对比" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/推荐好文/">推荐好文</a></p>
                            <p class="item-title"><a href="/2019/08/15/7种JVM垃圾收集器的对比/" class="title">7种JVM垃圾收集器的对比</a></p>
                            <p class="item-date"><time datetime="2019-08-15T07:43:11.000Z" itemprop="datePublished">2019-08-15</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2019/08/15/IDEA远程一键部署SpringBoot/" class="thumbnail">
    
    
        <span style="background-image:url(/2019/08/15/IDEA远程一键部署SpringBoot/5152858.jpg)" alt="IDEA远程一键部署SpringBoot" class="thumbnail-image"></span>
    
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/推荐好文/">推荐好文</a></p>
                            <p class="item-title"><a href="/2019/08/15/IDEA远程一键部署SpringBoot/" class="title">IDEA远程一键部署SpringBoot</a></p>
                            <p class="item-date"><time datetime="2019-08-15T07:27:31.000Z" itemprop="datePublished">2019-08-15</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JSP/">JSP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JVM/">JVM</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Javaweb/">Javaweb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jquery/">Jquery</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP/">PHP</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/XML/">XML</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajax/">ajax</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html/">html</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">15</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript库/">javascript库</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/maven/">maven</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node/">node</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/orcal/">orcal</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python/">python</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/struts2/">struts2</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/冷知识/">冷知识</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端/">前端</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开发工具/">开发工具</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/开源项目/">开源项目</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/心语/">心语</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/性能测试/">性能测试</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术/">技术</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/框架/">框架</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/浏览器/">浏览器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/缓存机制/">缓存机制</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/舆论/">舆论</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/项目用到/">项目用到</a><span class="tag-list-count">1</span></li></ul>
        </div>
    </div>


            
                
    <div class="widget-wrap widget-float">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/JSP/" style="font-size: 10px;">JSP</a> <a href="/tags/JVM/" style="font-size: 13px;">JVM</a> <a href="/tags/Java/" style="font-size: 16px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 19px;">JavaScript</a> <a href="/tags/Javaweb/" style="font-size: 10px;">Javaweb</a> <a href="/tags/Jquery/" style="font-size: 10px;">Jquery</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/PHP/" style="font-size: 17px;">PHP</a> <a href="/tags/XML/" style="font-size: 11px;">XML</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/git/" style="font-size: 11px;">git</a> <a href="/tags/html/" style="font-size: 18px;">html</a> <a href="/tags/java/" style="font-size: 19px;">java</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/javascript库/" style="font-size: 20px;">javascript库</a> <a href="/tags/maven/" style="font-size: 16px;">maven</a> <a href="/tags/node/" style="font-size: 11px;">node</a> <a href="/tags/orcal/" style="font-size: 14px;">orcal</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/struts2/" style="font-size: 10px;">struts2</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/冷知识/" style="font-size: 13px;">冷知识</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/开发工具/" style="font-size: 15px;">开发工具</a> <a href="/tags/开源项目/" style="font-size: 10px;">开源项目</a> <a href="/tags/心语/" style="font-size: 12px;">心语</a> <a href="/tags/性能测试/" style="font-size: 10px;">性能测试</a> <a href="/tags/技术/" style="font-size: 12px;">技术</a> <a href="/tags/数据结构与算法/" style="font-size: 16px;">数据结构与算法</a> <a href="/tags/框架/" style="font-size: 10px;">框架</a> <a href="/tags/浏览器/" style="font-size: 10px;">浏览器</a> <a href="/tags/缓存机制/" style="font-size: 10px;">缓存机制</a> <a href="/tags/舆论/" style="font-size: 10px;">舆论</a> <a href="/tags/项目用到/" style="font-size: 10px;">项目用到</a>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2019 陈义</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
            <div>
                <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
                本站总访问量 <span id="busuanzi_value_site_pv"></span> 次&nbsp&nbsp&nbsp
                本站访客数<span id="busuanzi_value_site_uv"></span>人次
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

        
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'http://yoursite.com/2019/05/14/kotlin概览以及团队实践/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
